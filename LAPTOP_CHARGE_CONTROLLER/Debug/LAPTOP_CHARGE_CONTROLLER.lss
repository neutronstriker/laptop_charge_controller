
LAPTOP_CHARGE_CONTROLLER.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000114  00800100  00001026  000010ba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001026  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000a7  00800214  00800214  000011ce  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000011ce  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001200  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002f0  00000000  00000000  00001240  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007e70  00000000  00000000  00001530  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001a01  00000000  00000000  000093a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001b68  00000000  00000000  0000ada1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000868  00000000  00000000  0000c90c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002167  00000000  00000000  0000d174  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002fbc  00000000  00000000  0000f2db  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002b8  00000000  00000000  00012297  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5d 00 	jmp	0xba	; 0xba <__ctors_end>
       4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
       8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
       c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      10:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      14:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      18:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      1c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      20:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      24:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      28:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      2c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      30:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      34:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      38:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      3c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      40:	0c 94 88 06 	jmp	0xd10	; 0xd10 <__vector_16>
      44:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      48:	0c 94 e3 04 	jmp	0x9c6	; 0x9c6 <__vector_18>
      4c:	0c 94 15 05 	jmp	0xa2a	; 0xa2a <__vector_19>
      50:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      54:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      58:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      5c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      60:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      64:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>

00000068 <__trampolines_end>:
      68:	00 00       	nop
      6a:	00 08       	sbc	r0, r0
      6c:	00 02       	muls	r16, r16
      6e:	01 00       	.word	0x0001	; ????
      70:	00 03       	mulsu	r16, r16
      72:	04 07       	cpc	r16, r20
	...

0000007c <digital_pin_to_bit_mask_PGM>:
      7c:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      8c:	04 08 10 20                                         ... 

00000090 <digital_pin_to_port_PGM>:
      90:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      a0:	03 03 03 03                                         ....

000000a4 <port_to_output_PGM>:
      a4:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

000000ae <port_to_mode_PGM>:
      ae:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

000000b8 <__ctors_start>:
      b8:	45 05       	cpc	r20, r5

000000ba <__ctors_end>:
      ba:	11 24       	eor	r1, r1
      bc:	1f be       	out	0x3f, r1	; 63
      be:	cf ef       	ldi	r28, 0xFF	; 255
      c0:	d8 e0       	ldi	r29, 0x08	; 8
      c2:	de bf       	out	0x3e, r29	; 62
      c4:	cd bf       	out	0x3d, r28	; 61

000000c6 <__do_copy_data>:
      c6:	12 e0       	ldi	r17, 0x02	; 2
      c8:	a0 e0       	ldi	r26, 0x00	; 0
      ca:	b1 e0       	ldi	r27, 0x01	; 1
      cc:	e6 e2       	ldi	r30, 0x26	; 38
      ce:	f0 e1       	ldi	r31, 0x10	; 16
      d0:	02 c0       	rjmp	.+4      	; 0xd6 <__do_copy_data+0x10>
      d2:	05 90       	lpm	r0, Z+
      d4:	0d 92       	st	X+, r0
      d6:	a4 31       	cpi	r26, 0x14	; 20
      d8:	b1 07       	cpc	r27, r17
      da:	d9 f7       	brne	.-10     	; 0xd2 <__do_copy_data+0xc>

000000dc <__do_clear_bss>:
      dc:	22 e0       	ldi	r18, 0x02	; 2
      de:	a4 e1       	ldi	r26, 0x14	; 20
      e0:	b2 e0       	ldi	r27, 0x02	; 2
      e2:	01 c0       	rjmp	.+2      	; 0xe6 <.do_clear_bss_start>

000000e4 <.do_clear_bss_loop>:
      e4:	1d 92       	st	X+, r1

000000e6 <.do_clear_bss_start>:
      e6:	ab 3b       	cpi	r26, 0xBB	; 187
      e8:	b2 07       	cpc	r27, r18
      ea:	e1 f7       	brne	.-8      	; 0xe4 <.do_clear_bss_loop>

000000ec <__do_global_ctors>:
      ec:	10 e0       	ldi	r17, 0x00	; 0
      ee:	cd e5       	ldi	r28, 0x5D	; 93
      f0:	d0 e0       	ldi	r29, 0x00	; 0
      f2:	04 c0       	rjmp	.+8      	; 0xfc <__do_global_ctors+0x10>
      f4:	21 97       	sbiw	r28, 0x01	; 1
      f6:	fe 01       	movw	r30, r28
      f8:	0e 94 0b 08 	call	0x1016	; 0x1016 <__tablejump2__>
      fc:	cc 35       	cpi	r28, 0x5C	; 92
      fe:	d1 07       	cpc	r29, r17
     100:	c9 f7       	brne	.-14     	; 0xf4 <__do_global_ctors+0x8>
     102:	0e 94 73 05 	call	0xae6	; 0xae6 <main>
     106:	0c 94 11 08 	jmp	0x1022	; 0x1022 <_exit>

0000010a <__bad_interrupt>:
     10a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000010e <_Z18getAcSupplyVoltagev>:
		index++;
		acVoltageSample = getAcSupplyVoltage();
	}
	float rmsVoltage= largestSample(acVoltagePosCycleSamples,index+1)/1.414; //Dividing peak value by crest factor of sine wave, sqrt(2).
	return (uint16_t)rmsVoltage;
}
     10e:	81 e1       	ldi	r24, 0x11	; 17
     110:	0e 94 10 07 	call	0xe20	; 0xe20 <analogRead>
     114:	bc 01       	movw	r22, r24
     116:	99 0f       	add	r25, r25
     118:	88 0b       	sbc	r24, r24
     11a:	99 0b       	sbc	r25, r25
     11c:	0e 94 b0 02 	call	0x560	; 0x560 <__floatsisf>
     120:	28 e5       	ldi	r18, 0x58	; 88
     122:	39 e3       	ldi	r19, 0x39	; 57
     124:	4c e9       	ldi	r20, 0x9C	; 156
     126:	50 e4       	ldi	r21, 0x40	; 64
     128:	0e 94 3c 03 	call	0x678	; 0x678 <__mulsf3>
     12c:	0e 94 7f 02 	call	0x4fe	; 0x4fe <__fixunssfsi>
     130:	80 e0       	ldi	r24, 0x00	; 0
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	0e 94 ae 02 	call	0x55c	; 0x55c <__floatunsisf>
     138:	20 e0       	ldi	r18, 0x00	; 0
     13a:	30 e0       	ldi	r19, 0x00	; 0
     13c:	4a e7       	ldi	r20, 0x7A	; 122
     13e:	54 e4       	ldi	r21, 0x44	; 68
     140:	0e 94 06 02 	call	0x40c	; 0x40c <__divsf3>
     144:	20 e0       	ldi	r18, 0x00	; 0
     146:	30 e8       	ldi	r19, 0x80	; 128
     148:	4d e3       	ldi	r20, 0x3D	; 61
     14a:	54 e4       	ldi	r21, 0x44	; 68
     14c:	0e 94 3c 03 	call	0x678	; 0x678 <__mulsf3>
     150:	20 e0       	ldi	r18, 0x00	; 0
     152:	30 ec       	ldi	r19, 0xC0	; 192
     154:	4c eb       	ldi	r20, 0xBC	; 188
     156:	54 e4       	ldi	r21, 0x44	; 68
     158:	0e 94 99 01 	call	0x332	; 0x332 <__subsf3>
     15c:	20 e0       	ldi	r18, 0x00	; 0
     15e:	30 e0       	ldi	r19, 0x00	; 0
     160:	40 e4       	ldi	r20, 0x40	; 64
     162:	50 e4       	ldi	r21, 0x40	; 64
     164:	0e 94 06 02 	call	0x40c	; 0x40c <__divsf3>
     168:	0e 94 78 02 	call	0x4f0	; 0x4f0 <__fixsfsi>
     16c:	cb 01       	movw	r24, r22
     16e:	08 95       	ret

00000170 <_Z23getAcsCurrentPinVoltagev>:

int16_t getAcsCurrentPinVoltage()
{
	//return (analogRead(ACS_CURRENT_SENSE_PIN_WITH_LPF)>>2); //shifting 2 bits to scale down 10 bit data to 8 bits, since for testing it will simpler to send 8bit data through UART.
	//update: since I am using currently Arduino's Serial plotter, it can automatically do the conversion from string to numbers and plot so directly sending measured current.
	int acsVoltage_offsetRemoved = (analogRead(ACS_CURRENT_SENSE_PIN_WITH_LPF)*4.88)-2500;
     170:	8e e0       	ldi	r24, 0x0E	; 14
     172:	0e 94 10 07 	call	0xe20	; 0xe20 <analogRead>
	return acsVoltage_offsetRemoved;
     176:	bc 01       	movw	r22, r24
     178:	99 0f       	add	r25, r25
     17a:	88 0b       	sbc	r24, r24
     17c:	99 0b       	sbc	r25, r25
     17e:	0e 94 b0 02 	call	0x560	; 0x560 <__floatsisf>
     182:	26 ef       	ldi	r18, 0xF6	; 246
     184:	38 e2       	ldi	r19, 0x28	; 40
     186:	4c e9       	ldi	r20, 0x9C	; 156
     188:	50 e4       	ldi	r21, 0x40	; 64
     18a:	0e 94 3c 03 	call	0x678	; 0x678 <__mulsf3>
     18e:	20 e0       	ldi	r18, 0x00	; 0
     190:	30 e4       	ldi	r19, 0x40	; 64
     192:	4c e1       	ldi	r20, 0x1C	; 28
     194:	55 e4       	ldi	r21, 0x45	; 69
     196:	0e 94 99 01 	call	0x332	; 0x332 <__subsf3>
     19a:	0e 94 78 02 	call	0x4f0	; 0x4f0 <__fixsfsi>
	//return (acsVoltage_offsetRemoved*1000.0)/185;
}
     19e:	cb 01       	movw	r24, r22
     1a0:	08 95       	ret

000001a2 <_Z21getAcCurrentMilliAmpsv>:

int getAcCurrentMilliAmps()
{
	return getAcsCurrentPinVoltage()*5.405; //multiplying with 1000/185
     1a2:	0e 94 b8 00 	call	0x170	; 0x170 <_Z23getAcsCurrentPinVoltagev>
     1a6:	bc 01       	movw	r22, r24
     1a8:	99 0f       	add	r25, r25
     1aa:	88 0b       	sbc	r24, r24
     1ac:	99 0b       	sbc	r25, r25
     1ae:	0e 94 b0 02 	call	0x560	; 0x560 <__floatsisf>
     1b2:	23 ec       	ldi	r18, 0xC3	; 195
     1b4:	35 ef       	ldi	r19, 0xF5	; 245
     1b6:	4c ea       	ldi	r20, 0xAC	; 172
     1b8:	50 e4       	ldi	r21, 0x40	; 64
     1ba:	0e 94 3c 03 	call	0x678	; 0x678 <__mulsf3>
     1be:	0e 94 78 02 	call	0x4f0	; 0x4f0 <__fixsfsi>
}
     1c2:	cb 01       	movw	r24, r22
     1c4:	08 95       	ret

000001c6 <_Z27acsCurrentAveragedMilliAmpsh>:

int acsCurrentAveragedMilliAmps(uint8_t averageSampleCount)
{
     1c6:	0f 93       	push	r16
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
     1ce:	d8 2f       	mov	r29, r24
	int sum = 0;	//take care of this var, if sample count is too high and the scaling factor in above function is also high it could be possible that, the combination could overflow the var range and calculation will be inaccurate.
	for (uint8_t i=0;i<averageSampleCount;i++)
     1d0:	c0 e0       	ldi	r28, 0x00	; 0
	return getAcsCurrentPinVoltage()*5.405; //multiplying with 1000/185
}

int acsCurrentAveragedMilliAmps(uint8_t averageSampleCount)
{
	int sum = 0;	//take care of this var, if sample count is too high and the scaling factor in above function is also high it could be possible that, the combination could overflow the var range and calculation will be inaccurate.
     1d2:	00 e0       	ldi	r16, 0x00	; 0
     1d4:	10 e0       	ldi	r17, 0x00	; 0
	for (uint8_t i=0;i<averageSampleCount;i++)
     1d6:	cd 17       	cp	r28, r29
     1d8:	31 f0       	breq	.+12     	; 0x1e6 <_Z27acsCurrentAveragedMilliAmpsh+0x20>
	{
		sum = sum + getAcCurrentMilliAmps();
     1da:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <_Z21getAcCurrentMilliAmpsv>
     1de:	08 0f       	add	r16, r24
     1e0:	19 1f       	adc	r17, r25
}

int acsCurrentAveragedMilliAmps(uint8_t averageSampleCount)
{
	int sum = 0;	//take care of this var, if sample count is too high and the scaling factor in above function is also high it could be possible that, the combination could overflow the var range and calculation will be inaccurate.
	for (uint8_t i=0;i<averageSampleCount;i++)
     1e2:	cf 5f       	subi	r28, 0xFF	; 255
     1e4:	f8 cf       	rjmp	.-16     	; 0x1d6 <_Z27acsCurrentAveragedMilliAmpsh+0x10>
	{
		sum = sum + getAcCurrentMilliAmps();
	}
	return sum/averageSampleCount;
     1e6:	6c 2f       	mov	r22, r28
     1e8:	70 e0       	ldi	r23, 0x00	; 0
     1ea:	c8 01       	movw	r24, r16
     1ec:	0e 94 c1 07 	call	0xf82	; 0xf82 <__divmodhi4>
     1f0:	cb 01       	movw	r24, r22
}
     1f2:	df 91       	pop	r29
     1f4:	cf 91       	pop	r28
     1f6:	1f 91       	pop	r17
     1f8:	0f 91       	pop	r16
     1fa:	08 95       	ret

000001fc <setup>:
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     1fc:	26 e0       	ldi	r18, 0x06	; 6
     1fe:	40 e0       	ldi	r20, 0x00	; 0
     200:	51 ee       	ldi	r21, 0xE1	; 225
     202:	60 e0       	ldi	r22, 0x00	; 0
     204:	70 e0       	ldi	r23, 0x00	; 0
     206:	85 e1       	ldi	r24, 0x15	; 21
     208:	92 e0       	ldi	r25, 0x02	; 2
     20a:	0e 94 7e 04 	call	0x8fc	; 0x8fc <_ZN14HardwareSerial5beginEmh>

void setup() {
  // put your setup code here, to run once:
	Serial.begin(57600);
	Serial.println("LAPTOP CHARGER CONTROLLER -- INITIALIZED");
     20e:	61 e0       	ldi	r22, 0x01	; 1
     210:	71 e0       	ldi	r23, 0x01	; 1
     212:	85 e1       	ldi	r24, 0x15	; 21
     214:	92 e0       	ldi	r25, 0x02	; 2
     216:	0e 94 cc 05 	call	0xb98	; 0xb98 <_ZN5Print7printlnEPKc>
	Serial.println("SUPPLY COMES FROM NC OF RELAY, DEFAULT IS POWER ON");
     21a:	6a e2       	ldi	r22, 0x2A	; 42
     21c:	71 e0       	ldi	r23, 0x01	; 1
     21e:	85 e1       	ldi	r24, 0x15	; 21
     220:	92 e0       	ldi	r25, 0x02	; 2
     222:	0e 94 cc 05 	call	0xb98	; 0xb98 <_ZN5Print7printlnEPKc>
	Serial.println("SEND>\r\n1: POWER ON\r\n0: POWER OFF");
     226:	6d e5       	ldi	r22, 0x5D	; 93
     228:	71 e0       	ldi	r23, 0x01	; 1
     22a:	85 e1       	ldi	r24, 0x15	; 21
     22c:	92 e0       	ldi	r25, 0x02	; 2
     22e:	0e 94 cc 05 	call	0xb98	; 0xb98 <_ZN5Print7printlnEPKc>
	Serial.println("SEND>\r\nA: ENABLE_CURRENT_STREAM\r\nB: DISABLE_CURRENT_STREAM");
     232:	6e e7       	ldi	r22, 0x7E	; 126
     234:	71 e0       	ldi	r23, 0x01	; 1
     236:	85 e1       	ldi	r24, 0x15	; 21
     238:	92 e0       	ldi	r25, 0x02	; 2
     23a:	0e 94 cc 05 	call	0xb98	; 0xb98 <_ZN5Print7printlnEPKc>
	Serial.println("Initialization Complete");
     23e:	69 eb       	ldi	r22, 0xB9	; 185
     240:	71 e0       	ldi	r23, 0x01	; 1
     242:	85 e1       	ldi	r24, 0x15	; 21
     244:	92 e0       	ldi	r25, 0x02	; 2
     246:	0e 94 cc 05 	call	0xb98	; 0xb98 <_ZN5Print7printlnEPKc>
	
	pinMode(RELAY_PIN,OUTPUT);
     24a:	61 e0       	ldi	r22, 0x01	; 1
     24c:	83 e0       	ldi	r24, 0x03	; 3
     24e:	0e 94 56 07 	call	0xeac	; 0xeac <pinMode>
	digitalWrite(RELAY_PIN,HIGH);
     252:	61 e0       	ldi	r22, 0x01	; 1
     254:	83 e0       	ldi	r24, 0x03	; 3
     256:	0e 94 92 07 	call	0xf24	; 0xf24 <digitalWrite>
	pinMode(ACS_CURRENT_SENSE_PIN_WITH_LPF,INPUT);
     25a:	60 e0       	ldi	r22, 0x00	; 0
     25c:	8e e0       	ldi	r24, 0x0E	; 14
     25e:	0e 94 56 07 	call	0xeac	; 0xeac <pinMode>
	pinMode(ACS_CURRENT_SENSE_PIN_RAW,INPUT);
     262:	60 e0       	ldi	r22, 0x00	; 0
     264:	8f e0       	ldi	r24, 0x0F	; 15
     266:	0e 94 56 07 	call	0xeac	; 0xeac <pinMode>
	pinMode(VCC_PROBE_PIN,INPUT);
     26a:	60 e0       	ldi	r22, 0x00	; 0
     26c:	83 e1       	ldi	r24, 0x13	; 19
     26e:	0e 94 56 07 	call	0xeac	; 0xeac <pinMode>
	pinMode(AC_SUPPLY_VOLTAGE_SENSE_PIN,INPUT);
     272:	60 e0       	ldi	r22, 0x00	; 0
     274:	81 e1       	ldi	r24, 0x11	; 17
     276:	0e 94 56 07 	call	0xeac	; 0xeac <pinMode>
	digitalWrite(ACS_CURRENT_SENSE_PIN_WITH_LPF,LOW);
     27a:	60 e0       	ldi	r22, 0x00	; 0
     27c:	8e e0       	ldi	r24, 0x0E	; 14
     27e:	0e 94 92 07 	call	0xf24	; 0xf24 <digitalWrite>
	digitalWrite(AC_SUPPLY_VOLTAGE_SENSE_PIN,LOW);
     282:	60 e0       	ldi	r22, 0x00	; 0
     284:	81 e1       	ldi	r24, 0x11	; 17
     286:	0e 94 92 07 	call	0xf24	; 0xf24 <digitalWrite>
	analogReference(DEFAULT);
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	0c 94 0d 07 	jmp	0xe1a	; 0xe1a <analogReference>

00000290 <loop>:
}

void loop() {
  // put your main code here, to run repeatedly:
	if (Serial.available())
     290:	85 e1       	ldi	r24, 0x15	; 21
     292:	92 e0       	ldi	r25, 0x02	; 2
     294:	0e 94 a9 03 	call	0x752	; 0x752 <_ZN14HardwareSerial9availableEv>
     298:	89 2b       	or	r24, r25
     29a:	61 f1       	breq	.+88     	; 0x2f4 <loop+0x64>
	{
		char c = Serial.read();
     29c:	85 e1       	ldi	r24, 0x15	; 21
     29e:	92 e0       	ldi	r25, 0x02	; 2
     2a0:	0e 94 c3 03 	call	0x786	; 0x786 <_ZN14HardwareSerial4readEv>
		switch(c)
     2a4:	99 27       	eor	r25, r25
     2a6:	81 33       	cpi	r24, 0x31	; 49
     2a8:	91 05       	cpc	r25, r1
     2aa:	99 f0       	breq	.+38     	; 0x2d2 <loop+0x42>
     2ac:	4c f4       	brge	.+18     	; 0x2c0 <loop+0x30>
     2ae:	c0 97       	sbiw	r24, 0x30	; 48
     2b0:	d9 f4       	brne	.+54     	; 0x2e8 <loop+0x58>
		{
			case '0': digitalWrite(RELAY_PIN,LOW);
     2b2:	60 e0       	ldi	r22, 0x00	; 0
     2b4:	83 e0       	ldi	r24, 0x03	; 3
     2b6:	0e 94 92 07 	call	0xf24	; 0xf24 <digitalWrite>
					Serial.println("POWER_OFF");
     2ba:	61 ed       	ldi	r22, 0xD1	; 209
     2bc:	71 e0       	ldi	r23, 0x01	; 1
     2be:	16 c0       	rjmp	.+44     	; 0x2ec <loop+0x5c>
void loop() {
  // put your main code here, to run repeatedly:
	if (Serial.available())
	{
		char c = Serial.read();
		switch(c)
     2c0:	81 34       	cpi	r24, 0x41	; 65
     2c2:	91 05       	cpc	r25, r1
     2c4:	69 f0       	breq	.+26     	; 0x2e0 <loop+0x50>
     2c6:	82 34       	cpi	r24, 0x42	; 66
     2c8:	91 05       	cpc	r25, r1
     2ca:	71 f4       	brne	.+28     	; 0x2e8 <loop+0x58>
					Serial.println("POWER_ON");
					break;
			case 'A':CURRENT_STREAM_FLAG = 1;
					//Serial.println("STREAMING_ON");
					break;
			case 'B':CURRENT_STREAM_FLAG = 0;
     2cc:	10 92 14 02 	sts	0x0214, r1	; 0x800214 <__data_end>
					//Serial.println("STREAMING_OFF");
					break;
     2d0:	11 c0       	rjmp	.+34     	; 0x2f4 <loop+0x64>
		switch(c)
		{
			case '0': digitalWrite(RELAY_PIN,LOW);
					Serial.println("POWER_OFF");
					break;
			case '1': digitalWrite(RELAY_PIN,HIGH);
     2d2:	61 e0       	ldi	r22, 0x01	; 1
     2d4:	83 e0       	ldi	r24, 0x03	; 3
     2d6:	0e 94 92 07 	call	0xf24	; 0xf24 <digitalWrite>
					Serial.println("POWER_ON");
     2da:	6b ed       	ldi	r22, 0xDB	; 219
     2dc:	71 e0       	ldi	r23, 0x01	; 1
     2de:	06 c0       	rjmp	.+12     	; 0x2ec <loop+0x5c>
					break;
			case 'A':CURRENT_STREAM_FLAG = 1;
     2e0:	81 e0       	ldi	r24, 0x01	; 1
     2e2:	80 93 14 02 	sts	0x0214, r24	; 0x800214 <__data_end>
					//Serial.println("STREAMING_ON");
					break;
     2e6:	06 c0       	rjmp	.+12     	; 0x2f4 <loop+0x64>
			case 'B':CURRENT_STREAM_FLAG = 0;
					//Serial.println("STREAMING_OFF");
					break;
			default:Serial.println("UNKNOWN_OPTION");
     2e8:	64 ee       	ldi	r22, 0xE4	; 228
     2ea:	71 e0       	ldi	r23, 0x01	; 1
     2ec:	85 e1       	ldi	r24, 0x15	; 21
     2ee:	92 e0       	ldi	r25, 0x02	; 2
     2f0:	0e 94 cc 05 	call	0xb98	; 0xb98 <_ZN5Print7printlnEPKc>
					break;
		}	
	}
	
	if (CURRENT_STREAM_FLAG)
     2f4:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <__data_end>
     2f8:	88 23       	and	r24, r24
     2fa:	d1 f0       	breq	.+52     	; 0x330 <loop+0xa0>
		
		
		//my test results show that the phase relationship between current and voltage with the below statements 
		//is still preserved, however I will have to test more by using a incandescent bulb. This test I did using laptop charger.
		//the captured data was plotted in excel, arduino plotter seems to used to different Y-axis scales for both plots but shows only one of them.
		Serial.print(acsCurrentAveragedMilliAmps(4));
     2fc:	84 e0       	ldi	r24, 0x04	; 4
     2fe:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <_Z27acsCurrentAveragedMilliAmpsh>
     302:	4a e0       	ldi	r20, 0x0A	; 10
     304:	50 e0       	ldi	r21, 0x00	; 0
     306:	bc 01       	movw	r22, r24
     308:	85 e1       	ldi	r24, 0x15	; 21
     30a:	92 e0       	ldi	r25, 0x02	; 2
     30c:	0e 94 6f 06 	call	0xcde	; 0xcde <_ZN5Print5printEii>
		Serial.print('\t');
     310:	69 e0       	ldi	r22, 0x09	; 9
     312:	85 e1       	ldi	r24, 0x15	; 21
     314:	92 e0       	ldi	r25, 0x02	; 2
     316:	0e 94 c1 05 	call	0xb82	; 0xb82 <_ZN5Print5printEc>
		Serial.println(getAcSupplyVoltage());
     31a:	0e 94 87 00 	call	0x10e	; 0x10e <_Z18getAcSupplyVoltagev>
     31e:	4a e0       	ldi	r20, 0x0A	; 10
     320:	50 e0       	ldi	r21, 0x00	; 0
     322:	bc 01       	movw	r22, r24
     324:	85 e1       	ldi	r24, 0x15	; 21
     326:	92 e0       	ldi	r25, 0x02	; 2
     328:	0e 94 76 06 	call	0xcec	; 0xcec <_ZN5Print7printlnEii>
		CURRENT_STREAM_FLAG = 0;//Python code was getting hung because of data stream overflow, so now I have implemented it as a function call
     32c:	10 92 14 02 	sts	0x0214, r1	; 0x800214 <__data_end>
     330:	08 95       	ret

00000332 <__subsf3>:
     332:	50 58       	subi	r21, 0x80	; 128

00000334 <__addsf3>:
     334:	bb 27       	eor	r27, r27
     336:	aa 27       	eor	r26, r26
     338:	0e 94 b1 01 	call	0x362	; 0x362 <__addsf3x>
     33c:	0c 94 02 03 	jmp	0x604	; 0x604 <__fp_round>
     340:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <__fp_pscA>
     344:	38 f0       	brcs	.+14     	; 0x354 <__addsf3+0x20>
     346:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <__fp_pscB>
     34a:	20 f0       	brcs	.+8      	; 0x354 <__addsf3+0x20>
     34c:	39 f4       	brne	.+14     	; 0x35c <__addsf3+0x28>
     34e:	9f 3f       	cpi	r25, 0xFF	; 255
     350:	19 f4       	brne	.+6      	; 0x358 <__addsf3+0x24>
     352:	26 f4       	brtc	.+8      	; 0x35c <__addsf3+0x28>
     354:	0c 94 f1 02 	jmp	0x5e2	; 0x5e2 <__fp_nan>
     358:	0e f4       	brtc	.+2      	; 0x35c <__addsf3+0x28>
     35a:	e0 95       	com	r30
     35c:	e7 fb       	bst	r30, 7
     35e:	0c 94 eb 02 	jmp	0x5d6	; 0x5d6 <__fp_inf>

00000362 <__addsf3x>:
     362:	e9 2f       	mov	r30, r25
     364:	0e 94 13 03 	call	0x626	; 0x626 <__fp_split3>
     368:	58 f3       	brcs	.-42     	; 0x340 <__addsf3+0xc>
     36a:	ba 17       	cp	r27, r26
     36c:	62 07       	cpc	r22, r18
     36e:	73 07       	cpc	r23, r19
     370:	84 07       	cpc	r24, r20
     372:	95 07       	cpc	r25, r21
     374:	20 f0       	brcs	.+8      	; 0x37e <__addsf3x+0x1c>
     376:	79 f4       	brne	.+30     	; 0x396 <__addsf3x+0x34>
     378:	a6 f5       	brtc	.+104    	; 0x3e2 <__addsf3x+0x80>
     37a:	0c 94 35 03 	jmp	0x66a	; 0x66a <__fp_zero>
     37e:	0e f4       	brtc	.+2      	; 0x382 <__addsf3x+0x20>
     380:	e0 95       	com	r30
     382:	0b 2e       	mov	r0, r27
     384:	ba 2f       	mov	r27, r26
     386:	a0 2d       	mov	r26, r0
     388:	0b 01       	movw	r0, r22
     38a:	b9 01       	movw	r22, r18
     38c:	90 01       	movw	r18, r0
     38e:	0c 01       	movw	r0, r24
     390:	ca 01       	movw	r24, r20
     392:	a0 01       	movw	r20, r0
     394:	11 24       	eor	r1, r1
     396:	ff 27       	eor	r31, r31
     398:	59 1b       	sub	r21, r25
     39a:	99 f0       	breq	.+38     	; 0x3c2 <__addsf3x+0x60>
     39c:	59 3f       	cpi	r21, 0xF9	; 249
     39e:	50 f4       	brcc	.+20     	; 0x3b4 <__addsf3x+0x52>
     3a0:	50 3e       	cpi	r21, 0xE0	; 224
     3a2:	68 f1       	brcs	.+90     	; 0x3fe <__addsf3x+0x9c>
     3a4:	1a 16       	cp	r1, r26
     3a6:	f0 40       	sbci	r31, 0x00	; 0
     3a8:	a2 2f       	mov	r26, r18
     3aa:	23 2f       	mov	r18, r19
     3ac:	34 2f       	mov	r19, r20
     3ae:	44 27       	eor	r20, r20
     3b0:	58 5f       	subi	r21, 0xF8	; 248
     3b2:	f3 cf       	rjmp	.-26     	; 0x39a <__addsf3x+0x38>
     3b4:	46 95       	lsr	r20
     3b6:	37 95       	ror	r19
     3b8:	27 95       	ror	r18
     3ba:	a7 95       	ror	r26
     3bc:	f0 40       	sbci	r31, 0x00	; 0
     3be:	53 95       	inc	r21
     3c0:	c9 f7       	brne	.-14     	; 0x3b4 <__addsf3x+0x52>
     3c2:	7e f4       	brtc	.+30     	; 0x3e2 <__addsf3x+0x80>
     3c4:	1f 16       	cp	r1, r31
     3c6:	ba 0b       	sbc	r27, r26
     3c8:	62 0b       	sbc	r22, r18
     3ca:	73 0b       	sbc	r23, r19
     3cc:	84 0b       	sbc	r24, r20
     3ce:	ba f0       	brmi	.+46     	; 0x3fe <__addsf3x+0x9c>
     3d0:	91 50       	subi	r25, 0x01	; 1
     3d2:	a1 f0       	breq	.+40     	; 0x3fc <__addsf3x+0x9a>
     3d4:	ff 0f       	add	r31, r31
     3d6:	bb 1f       	adc	r27, r27
     3d8:	66 1f       	adc	r22, r22
     3da:	77 1f       	adc	r23, r23
     3dc:	88 1f       	adc	r24, r24
     3de:	c2 f7       	brpl	.-16     	; 0x3d0 <__addsf3x+0x6e>
     3e0:	0e c0       	rjmp	.+28     	; 0x3fe <__addsf3x+0x9c>
     3e2:	ba 0f       	add	r27, r26
     3e4:	62 1f       	adc	r22, r18
     3e6:	73 1f       	adc	r23, r19
     3e8:	84 1f       	adc	r24, r20
     3ea:	48 f4       	brcc	.+18     	; 0x3fe <__addsf3x+0x9c>
     3ec:	87 95       	ror	r24
     3ee:	77 95       	ror	r23
     3f0:	67 95       	ror	r22
     3f2:	b7 95       	ror	r27
     3f4:	f7 95       	ror	r31
     3f6:	9e 3f       	cpi	r25, 0xFE	; 254
     3f8:	08 f0       	brcs	.+2      	; 0x3fc <__addsf3x+0x9a>
     3fa:	b0 cf       	rjmp	.-160    	; 0x35c <__addsf3+0x28>
     3fc:	93 95       	inc	r25
     3fe:	88 0f       	add	r24, r24
     400:	08 f0       	brcs	.+2      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     402:	99 27       	eor	r25, r25
     404:	ee 0f       	add	r30, r30
     406:	97 95       	ror	r25
     408:	87 95       	ror	r24
     40a:	08 95       	ret

0000040c <__divsf3>:
     40c:	0e 94 1a 02 	call	0x434	; 0x434 <__divsf3x>
     410:	0c 94 02 03 	jmp	0x604	; 0x604 <__fp_round>
     414:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <__fp_pscB>
     418:	58 f0       	brcs	.+22     	; 0x430 <__divsf3+0x24>
     41a:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <__fp_pscA>
     41e:	40 f0       	brcs	.+16     	; 0x430 <__divsf3+0x24>
     420:	29 f4       	brne	.+10     	; 0x42c <__divsf3+0x20>
     422:	5f 3f       	cpi	r21, 0xFF	; 255
     424:	29 f0       	breq	.+10     	; 0x430 <__divsf3+0x24>
     426:	0c 94 eb 02 	jmp	0x5d6	; 0x5d6 <__fp_inf>
     42a:	51 11       	cpse	r21, r1
     42c:	0c 94 36 03 	jmp	0x66c	; 0x66c <__fp_szero>
     430:	0c 94 f1 02 	jmp	0x5e2	; 0x5e2 <__fp_nan>

00000434 <__divsf3x>:
     434:	0e 94 13 03 	call	0x626	; 0x626 <__fp_split3>
     438:	68 f3       	brcs	.-38     	; 0x414 <__divsf3+0x8>

0000043a <__divsf3_pse>:
     43a:	99 23       	and	r25, r25
     43c:	b1 f3       	breq	.-20     	; 0x42a <__divsf3+0x1e>
     43e:	55 23       	and	r21, r21
     440:	91 f3       	breq	.-28     	; 0x426 <__divsf3+0x1a>
     442:	95 1b       	sub	r25, r21
     444:	55 0b       	sbc	r21, r21
     446:	bb 27       	eor	r27, r27
     448:	aa 27       	eor	r26, r26
     44a:	62 17       	cp	r22, r18
     44c:	73 07       	cpc	r23, r19
     44e:	84 07       	cpc	r24, r20
     450:	38 f0       	brcs	.+14     	; 0x460 <__divsf3_pse+0x26>
     452:	9f 5f       	subi	r25, 0xFF	; 255
     454:	5f 4f       	sbci	r21, 0xFF	; 255
     456:	22 0f       	add	r18, r18
     458:	33 1f       	adc	r19, r19
     45a:	44 1f       	adc	r20, r20
     45c:	aa 1f       	adc	r26, r26
     45e:	a9 f3       	breq	.-22     	; 0x44a <__divsf3_pse+0x10>
     460:	35 d0       	rcall	.+106    	; 0x4cc <__divsf3_pse+0x92>
     462:	0e 2e       	mov	r0, r30
     464:	3a f0       	brmi	.+14     	; 0x474 <__divsf3_pse+0x3a>
     466:	e0 e8       	ldi	r30, 0x80	; 128
     468:	32 d0       	rcall	.+100    	; 0x4ce <__divsf3_pse+0x94>
     46a:	91 50       	subi	r25, 0x01	; 1
     46c:	50 40       	sbci	r21, 0x00	; 0
     46e:	e6 95       	lsr	r30
     470:	00 1c       	adc	r0, r0
     472:	ca f7       	brpl	.-14     	; 0x466 <__divsf3_pse+0x2c>
     474:	2b d0       	rcall	.+86     	; 0x4cc <__divsf3_pse+0x92>
     476:	fe 2f       	mov	r31, r30
     478:	29 d0       	rcall	.+82     	; 0x4cc <__divsf3_pse+0x92>
     47a:	66 0f       	add	r22, r22
     47c:	77 1f       	adc	r23, r23
     47e:	88 1f       	adc	r24, r24
     480:	bb 1f       	adc	r27, r27
     482:	26 17       	cp	r18, r22
     484:	37 07       	cpc	r19, r23
     486:	48 07       	cpc	r20, r24
     488:	ab 07       	cpc	r26, r27
     48a:	b0 e8       	ldi	r27, 0x80	; 128
     48c:	09 f0       	breq	.+2      	; 0x490 <__divsf3_pse+0x56>
     48e:	bb 0b       	sbc	r27, r27
     490:	80 2d       	mov	r24, r0
     492:	bf 01       	movw	r22, r30
     494:	ff 27       	eor	r31, r31
     496:	93 58       	subi	r25, 0x83	; 131
     498:	5f 4f       	sbci	r21, 0xFF	; 255
     49a:	3a f0       	brmi	.+14     	; 0x4aa <__divsf3_pse+0x70>
     49c:	9e 3f       	cpi	r25, 0xFE	; 254
     49e:	51 05       	cpc	r21, r1
     4a0:	78 f0       	brcs	.+30     	; 0x4c0 <__divsf3_pse+0x86>
     4a2:	0c 94 eb 02 	jmp	0x5d6	; 0x5d6 <__fp_inf>
     4a6:	0c 94 36 03 	jmp	0x66c	; 0x66c <__fp_szero>
     4aa:	5f 3f       	cpi	r21, 0xFF	; 255
     4ac:	e4 f3       	brlt	.-8      	; 0x4a6 <__divsf3_pse+0x6c>
     4ae:	98 3e       	cpi	r25, 0xE8	; 232
     4b0:	d4 f3       	brlt	.-12     	; 0x4a6 <__divsf3_pse+0x6c>
     4b2:	86 95       	lsr	r24
     4b4:	77 95       	ror	r23
     4b6:	67 95       	ror	r22
     4b8:	b7 95       	ror	r27
     4ba:	f7 95       	ror	r31
     4bc:	9f 5f       	subi	r25, 0xFF	; 255
     4be:	c9 f7       	brne	.-14     	; 0x4b2 <__divsf3_pse+0x78>
     4c0:	88 0f       	add	r24, r24
     4c2:	91 1d       	adc	r25, r1
     4c4:	96 95       	lsr	r25
     4c6:	87 95       	ror	r24
     4c8:	97 f9       	bld	r25, 7
     4ca:	08 95       	ret
     4cc:	e1 e0       	ldi	r30, 0x01	; 1
     4ce:	66 0f       	add	r22, r22
     4d0:	77 1f       	adc	r23, r23
     4d2:	88 1f       	adc	r24, r24
     4d4:	bb 1f       	adc	r27, r27
     4d6:	62 17       	cp	r22, r18
     4d8:	73 07       	cpc	r23, r19
     4da:	84 07       	cpc	r24, r20
     4dc:	ba 07       	cpc	r27, r26
     4de:	20 f0       	brcs	.+8      	; 0x4e8 <__divsf3_pse+0xae>
     4e0:	62 1b       	sub	r22, r18
     4e2:	73 0b       	sbc	r23, r19
     4e4:	84 0b       	sbc	r24, r20
     4e6:	ba 0b       	sbc	r27, r26
     4e8:	ee 1f       	adc	r30, r30
     4ea:	88 f7       	brcc	.-30     	; 0x4ce <__divsf3_pse+0x94>
     4ec:	e0 95       	com	r30
     4ee:	08 95       	ret

000004f0 <__fixsfsi>:
     4f0:	0e 94 7f 02 	call	0x4fe	; 0x4fe <__fixunssfsi>
     4f4:	68 94       	set
     4f6:	b1 11       	cpse	r27, r1
     4f8:	0c 94 36 03 	jmp	0x66c	; 0x66c <__fp_szero>
     4fc:	08 95       	ret

000004fe <__fixunssfsi>:
     4fe:	0e 94 1b 03 	call	0x636	; 0x636 <__fp_splitA>
     502:	88 f0       	brcs	.+34     	; 0x526 <__fixunssfsi+0x28>
     504:	9f 57       	subi	r25, 0x7F	; 127
     506:	98 f0       	brcs	.+38     	; 0x52e <__fixunssfsi+0x30>
     508:	b9 2f       	mov	r27, r25
     50a:	99 27       	eor	r25, r25
     50c:	b7 51       	subi	r27, 0x17	; 23
     50e:	b0 f0       	brcs	.+44     	; 0x53c <__fixunssfsi+0x3e>
     510:	e1 f0       	breq	.+56     	; 0x54a <__fixunssfsi+0x4c>
     512:	66 0f       	add	r22, r22
     514:	77 1f       	adc	r23, r23
     516:	88 1f       	adc	r24, r24
     518:	99 1f       	adc	r25, r25
     51a:	1a f0       	brmi	.+6      	; 0x522 <__fixunssfsi+0x24>
     51c:	ba 95       	dec	r27
     51e:	c9 f7       	brne	.-14     	; 0x512 <__fixunssfsi+0x14>
     520:	14 c0       	rjmp	.+40     	; 0x54a <__fixunssfsi+0x4c>
     522:	b1 30       	cpi	r27, 0x01	; 1
     524:	91 f0       	breq	.+36     	; 0x54a <__fixunssfsi+0x4c>
     526:	0e 94 35 03 	call	0x66a	; 0x66a <__fp_zero>
     52a:	b1 e0       	ldi	r27, 0x01	; 1
     52c:	08 95       	ret
     52e:	0c 94 35 03 	jmp	0x66a	; 0x66a <__fp_zero>
     532:	67 2f       	mov	r22, r23
     534:	78 2f       	mov	r23, r24
     536:	88 27       	eor	r24, r24
     538:	b8 5f       	subi	r27, 0xF8	; 248
     53a:	39 f0       	breq	.+14     	; 0x54a <__fixunssfsi+0x4c>
     53c:	b9 3f       	cpi	r27, 0xF9	; 249
     53e:	cc f3       	brlt	.-14     	; 0x532 <__fixunssfsi+0x34>
     540:	86 95       	lsr	r24
     542:	77 95       	ror	r23
     544:	67 95       	ror	r22
     546:	b3 95       	inc	r27
     548:	d9 f7       	brne	.-10     	; 0x540 <__fixunssfsi+0x42>
     54a:	3e f4       	brtc	.+14     	; 0x55a <__fixunssfsi+0x5c>
     54c:	90 95       	com	r25
     54e:	80 95       	com	r24
     550:	70 95       	com	r23
     552:	61 95       	neg	r22
     554:	7f 4f       	sbci	r23, 0xFF	; 255
     556:	8f 4f       	sbci	r24, 0xFF	; 255
     558:	9f 4f       	sbci	r25, 0xFF	; 255
     55a:	08 95       	ret

0000055c <__floatunsisf>:
     55c:	e8 94       	clt
     55e:	09 c0       	rjmp	.+18     	; 0x572 <__floatsisf+0x12>

00000560 <__floatsisf>:
     560:	97 fb       	bst	r25, 7
     562:	3e f4       	brtc	.+14     	; 0x572 <__floatsisf+0x12>
     564:	90 95       	com	r25
     566:	80 95       	com	r24
     568:	70 95       	com	r23
     56a:	61 95       	neg	r22
     56c:	7f 4f       	sbci	r23, 0xFF	; 255
     56e:	8f 4f       	sbci	r24, 0xFF	; 255
     570:	9f 4f       	sbci	r25, 0xFF	; 255
     572:	99 23       	and	r25, r25
     574:	a9 f0       	breq	.+42     	; 0x5a0 <__floatsisf+0x40>
     576:	f9 2f       	mov	r31, r25
     578:	96 e9       	ldi	r25, 0x96	; 150
     57a:	bb 27       	eor	r27, r27
     57c:	93 95       	inc	r25
     57e:	f6 95       	lsr	r31
     580:	87 95       	ror	r24
     582:	77 95       	ror	r23
     584:	67 95       	ror	r22
     586:	b7 95       	ror	r27
     588:	f1 11       	cpse	r31, r1
     58a:	f8 cf       	rjmp	.-16     	; 0x57c <__floatsisf+0x1c>
     58c:	fa f4       	brpl	.+62     	; 0x5cc <__floatsisf+0x6c>
     58e:	bb 0f       	add	r27, r27
     590:	11 f4       	brne	.+4      	; 0x596 <__floatsisf+0x36>
     592:	60 ff       	sbrs	r22, 0
     594:	1b c0       	rjmp	.+54     	; 0x5cc <__floatsisf+0x6c>
     596:	6f 5f       	subi	r22, 0xFF	; 255
     598:	7f 4f       	sbci	r23, 0xFF	; 255
     59a:	8f 4f       	sbci	r24, 0xFF	; 255
     59c:	9f 4f       	sbci	r25, 0xFF	; 255
     59e:	16 c0       	rjmp	.+44     	; 0x5cc <__floatsisf+0x6c>
     5a0:	88 23       	and	r24, r24
     5a2:	11 f0       	breq	.+4      	; 0x5a8 <__floatsisf+0x48>
     5a4:	96 e9       	ldi	r25, 0x96	; 150
     5a6:	11 c0       	rjmp	.+34     	; 0x5ca <__floatsisf+0x6a>
     5a8:	77 23       	and	r23, r23
     5aa:	21 f0       	breq	.+8      	; 0x5b4 <__floatsisf+0x54>
     5ac:	9e e8       	ldi	r25, 0x8E	; 142
     5ae:	87 2f       	mov	r24, r23
     5b0:	76 2f       	mov	r23, r22
     5b2:	05 c0       	rjmp	.+10     	; 0x5be <__floatsisf+0x5e>
     5b4:	66 23       	and	r22, r22
     5b6:	71 f0       	breq	.+28     	; 0x5d4 <__floatsisf+0x74>
     5b8:	96 e8       	ldi	r25, 0x86	; 134
     5ba:	86 2f       	mov	r24, r22
     5bc:	70 e0       	ldi	r23, 0x00	; 0
     5be:	60 e0       	ldi	r22, 0x00	; 0
     5c0:	2a f0       	brmi	.+10     	; 0x5cc <__floatsisf+0x6c>
     5c2:	9a 95       	dec	r25
     5c4:	66 0f       	add	r22, r22
     5c6:	77 1f       	adc	r23, r23
     5c8:	88 1f       	adc	r24, r24
     5ca:	da f7       	brpl	.-10     	; 0x5c2 <__floatsisf+0x62>
     5cc:	88 0f       	add	r24, r24
     5ce:	96 95       	lsr	r25
     5d0:	87 95       	ror	r24
     5d2:	97 f9       	bld	r25, 7
     5d4:	08 95       	ret

000005d6 <__fp_inf>:
     5d6:	97 f9       	bld	r25, 7
     5d8:	9f 67       	ori	r25, 0x7F	; 127
     5da:	80 e8       	ldi	r24, 0x80	; 128
     5dc:	70 e0       	ldi	r23, 0x00	; 0
     5de:	60 e0       	ldi	r22, 0x00	; 0
     5e0:	08 95       	ret

000005e2 <__fp_nan>:
     5e2:	9f ef       	ldi	r25, 0xFF	; 255
     5e4:	80 ec       	ldi	r24, 0xC0	; 192
     5e6:	08 95       	ret

000005e8 <__fp_pscA>:
     5e8:	00 24       	eor	r0, r0
     5ea:	0a 94       	dec	r0
     5ec:	16 16       	cp	r1, r22
     5ee:	17 06       	cpc	r1, r23
     5f0:	18 06       	cpc	r1, r24
     5f2:	09 06       	cpc	r0, r25
     5f4:	08 95       	ret

000005f6 <__fp_pscB>:
     5f6:	00 24       	eor	r0, r0
     5f8:	0a 94       	dec	r0
     5fa:	12 16       	cp	r1, r18
     5fc:	13 06       	cpc	r1, r19
     5fe:	14 06       	cpc	r1, r20
     600:	05 06       	cpc	r0, r21
     602:	08 95       	ret

00000604 <__fp_round>:
     604:	09 2e       	mov	r0, r25
     606:	03 94       	inc	r0
     608:	00 0c       	add	r0, r0
     60a:	11 f4       	brne	.+4      	; 0x610 <__fp_round+0xc>
     60c:	88 23       	and	r24, r24
     60e:	52 f0       	brmi	.+20     	; 0x624 <__fp_round+0x20>
     610:	bb 0f       	add	r27, r27
     612:	40 f4       	brcc	.+16     	; 0x624 <__fp_round+0x20>
     614:	bf 2b       	or	r27, r31
     616:	11 f4       	brne	.+4      	; 0x61c <__fp_round+0x18>
     618:	60 ff       	sbrs	r22, 0
     61a:	04 c0       	rjmp	.+8      	; 0x624 <__fp_round+0x20>
     61c:	6f 5f       	subi	r22, 0xFF	; 255
     61e:	7f 4f       	sbci	r23, 0xFF	; 255
     620:	8f 4f       	sbci	r24, 0xFF	; 255
     622:	9f 4f       	sbci	r25, 0xFF	; 255
     624:	08 95       	ret

00000626 <__fp_split3>:
     626:	57 fd       	sbrc	r21, 7
     628:	90 58       	subi	r25, 0x80	; 128
     62a:	44 0f       	add	r20, r20
     62c:	55 1f       	adc	r21, r21
     62e:	59 f0       	breq	.+22     	; 0x646 <__fp_splitA+0x10>
     630:	5f 3f       	cpi	r21, 0xFF	; 255
     632:	71 f0       	breq	.+28     	; 0x650 <__fp_splitA+0x1a>
     634:	47 95       	ror	r20

00000636 <__fp_splitA>:
     636:	88 0f       	add	r24, r24
     638:	97 fb       	bst	r25, 7
     63a:	99 1f       	adc	r25, r25
     63c:	61 f0       	breq	.+24     	; 0x656 <__fp_splitA+0x20>
     63e:	9f 3f       	cpi	r25, 0xFF	; 255
     640:	79 f0       	breq	.+30     	; 0x660 <__fp_splitA+0x2a>
     642:	87 95       	ror	r24
     644:	08 95       	ret
     646:	12 16       	cp	r1, r18
     648:	13 06       	cpc	r1, r19
     64a:	14 06       	cpc	r1, r20
     64c:	55 1f       	adc	r21, r21
     64e:	f2 cf       	rjmp	.-28     	; 0x634 <__fp_split3+0xe>
     650:	46 95       	lsr	r20
     652:	f1 df       	rcall	.-30     	; 0x636 <__fp_splitA>
     654:	08 c0       	rjmp	.+16     	; 0x666 <__fp_splitA+0x30>
     656:	16 16       	cp	r1, r22
     658:	17 06       	cpc	r1, r23
     65a:	18 06       	cpc	r1, r24
     65c:	99 1f       	adc	r25, r25
     65e:	f1 cf       	rjmp	.-30     	; 0x642 <__fp_splitA+0xc>
     660:	86 95       	lsr	r24
     662:	71 05       	cpc	r23, r1
     664:	61 05       	cpc	r22, r1
     666:	08 94       	sec
     668:	08 95       	ret

0000066a <__fp_zero>:
     66a:	e8 94       	clt

0000066c <__fp_szero>:
     66c:	bb 27       	eor	r27, r27
     66e:	66 27       	eor	r22, r22
     670:	77 27       	eor	r23, r23
     672:	cb 01       	movw	r24, r22
     674:	97 f9       	bld	r25, 7
     676:	08 95       	ret

00000678 <__mulsf3>:
     678:	0e 94 4f 03 	call	0x69e	; 0x69e <__mulsf3x>
     67c:	0c 94 02 03 	jmp	0x604	; 0x604 <__fp_round>
     680:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <__fp_pscA>
     684:	38 f0       	brcs	.+14     	; 0x694 <__mulsf3+0x1c>
     686:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <__fp_pscB>
     68a:	20 f0       	brcs	.+8      	; 0x694 <__mulsf3+0x1c>
     68c:	95 23       	and	r25, r21
     68e:	11 f0       	breq	.+4      	; 0x694 <__mulsf3+0x1c>
     690:	0c 94 eb 02 	jmp	0x5d6	; 0x5d6 <__fp_inf>
     694:	0c 94 f1 02 	jmp	0x5e2	; 0x5e2 <__fp_nan>
     698:	11 24       	eor	r1, r1
     69a:	0c 94 36 03 	jmp	0x66c	; 0x66c <__fp_szero>

0000069e <__mulsf3x>:
     69e:	0e 94 13 03 	call	0x626	; 0x626 <__fp_split3>
     6a2:	70 f3       	brcs	.-36     	; 0x680 <__mulsf3+0x8>

000006a4 <__mulsf3_pse>:
     6a4:	95 9f       	mul	r25, r21
     6a6:	c1 f3       	breq	.-16     	; 0x698 <__mulsf3+0x20>
     6a8:	95 0f       	add	r25, r21
     6aa:	50 e0       	ldi	r21, 0x00	; 0
     6ac:	55 1f       	adc	r21, r21
     6ae:	62 9f       	mul	r22, r18
     6b0:	f0 01       	movw	r30, r0
     6b2:	72 9f       	mul	r23, r18
     6b4:	bb 27       	eor	r27, r27
     6b6:	f0 0d       	add	r31, r0
     6b8:	b1 1d       	adc	r27, r1
     6ba:	63 9f       	mul	r22, r19
     6bc:	aa 27       	eor	r26, r26
     6be:	f0 0d       	add	r31, r0
     6c0:	b1 1d       	adc	r27, r1
     6c2:	aa 1f       	adc	r26, r26
     6c4:	64 9f       	mul	r22, r20
     6c6:	66 27       	eor	r22, r22
     6c8:	b0 0d       	add	r27, r0
     6ca:	a1 1d       	adc	r26, r1
     6cc:	66 1f       	adc	r22, r22
     6ce:	82 9f       	mul	r24, r18
     6d0:	22 27       	eor	r18, r18
     6d2:	b0 0d       	add	r27, r0
     6d4:	a1 1d       	adc	r26, r1
     6d6:	62 1f       	adc	r22, r18
     6d8:	73 9f       	mul	r23, r19
     6da:	b0 0d       	add	r27, r0
     6dc:	a1 1d       	adc	r26, r1
     6de:	62 1f       	adc	r22, r18
     6e0:	83 9f       	mul	r24, r19
     6e2:	a0 0d       	add	r26, r0
     6e4:	61 1d       	adc	r22, r1
     6e6:	22 1f       	adc	r18, r18
     6e8:	74 9f       	mul	r23, r20
     6ea:	33 27       	eor	r19, r19
     6ec:	a0 0d       	add	r26, r0
     6ee:	61 1d       	adc	r22, r1
     6f0:	23 1f       	adc	r18, r19
     6f2:	84 9f       	mul	r24, r20
     6f4:	60 0d       	add	r22, r0
     6f6:	21 1d       	adc	r18, r1
     6f8:	82 2f       	mov	r24, r18
     6fa:	76 2f       	mov	r23, r22
     6fc:	6a 2f       	mov	r22, r26
     6fe:	11 24       	eor	r1, r1
     700:	9f 57       	subi	r25, 0x7F	; 127
     702:	50 40       	sbci	r21, 0x00	; 0
     704:	9a f0       	brmi	.+38     	; 0x72c <__mulsf3_pse+0x88>
     706:	f1 f0       	breq	.+60     	; 0x744 <__mulsf3_pse+0xa0>
     708:	88 23       	and	r24, r24
     70a:	4a f0       	brmi	.+18     	; 0x71e <__mulsf3_pse+0x7a>
     70c:	ee 0f       	add	r30, r30
     70e:	ff 1f       	adc	r31, r31
     710:	bb 1f       	adc	r27, r27
     712:	66 1f       	adc	r22, r22
     714:	77 1f       	adc	r23, r23
     716:	88 1f       	adc	r24, r24
     718:	91 50       	subi	r25, 0x01	; 1
     71a:	50 40       	sbci	r21, 0x00	; 0
     71c:	a9 f7       	brne	.-22     	; 0x708 <__mulsf3_pse+0x64>
     71e:	9e 3f       	cpi	r25, 0xFE	; 254
     720:	51 05       	cpc	r21, r1
     722:	80 f0       	brcs	.+32     	; 0x744 <__mulsf3_pse+0xa0>
     724:	0c 94 eb 02 	jmp	0x5d6	; 0x5d6 <__fp_inf>
     728:	0c 94 36 03 	jmp	0x66c	; 0x66c <__fp_szero>
     72c:	5f 3f       	cpi	r21, 0xFF	; 255
     72e:	e4 f3       	brlt	.-8      	; 0x728 <__mulsf3_pse+0x84>
     730:	98 3e       	cpi	r25, 0xE8	; 232
     732:	d4 f3       	brlt	.-12     	; 0x728 <__mulsf3_pse+0x84>
     734:	86 95       	lsr	r24
     736:	77 95       	ror	r23
     738:	67 95       	ror	r22
     73a:	b7 95       	ror	r27
     73c:	f7 95       	ror	r31
     73e:	e7 95       	ror	r30
     740:	9f 5f       	subi	r25, 0xFF	; 255
     742:	c1 f7       	brne	.-16     	; 0x734 <__mulsf3_pse+0x90>
     744:	fe 2b       	or	r31, r30
     746:	88 0f       	add	r24, r24
     748:	91 1d       	adc	r25, r1
     74a:	96 95       	lsr	r25
     74c:	87 95       	ror	r24
     74e:	97 f9       	bld	r25, 7
     750:	08 95       	ret

00000752 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     752:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     754:	91 8d       	ldd	r25, Z+25	; 0x19
     756:	22 8d       	ldd	r18, Z+26	; 0x1a
     758:	89 2f       	mov	r24, r25
     75a:	90 e0       	ldi	r25, 0x00	; 0
     75c:	80 5c       	subi	r24, 0xC0	; 192
     75e:	9f 4f       	sbci	r25, 0xFF	; 255
     760:	82 1b       	sub	r24, r18
     762:	91 09       	sbc	r25, r1
}
     764:	8f 73       	andi	r24, 0x3F	; 63
     766:	99 27       	eor	r25, r25
     768:	08 95       	ret

0000076a <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
     76a:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
     76c:	91 8d       	ldd	r25, Z+25	; 0x19
     76e:	82 8d       	ldd	r24, Z+26	; 0x1a
     770:	98 17       	cp	r25, r24
     772:	31 f0       	breq	.+12     	; 0x780 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     774:	82 8d       	ldd	r24, Z+26	; 0x1a
     776:	e8 0f       	add	r30, r24
     778:	f1 1d       	adc	r31, r1
     77a:	85 8d       	ldd	r24, Z+29	; 0x1d
     77c:	90 e0       	ldi	r25, 0x00	; 0
     77e:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     780:	8f ef       	ldi	r24, 0xFF	; 255
     782:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     784:	08 95       	ret

00000786 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
     786:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     788:	91 8d       	ldd	r25, Z+25	; 0x19
     78a:	82 8d       	ldd	r24, Z+26	; 0x1a
     78c:	98 17       	cp	r25, r24
     78e:	61 f0       	breq	.+24     	; 0x7a8 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     790:	82 8d       	ldd	r24, Z+26	; 0x1a
     792:	df 01       	movw	r26, r30
     794:	a8 0f       	add	r26, r24
     796:	b1 1d       	adc	r27, r1
     798:	5d 96       	adiw	r26, 0x1d	; 29
     79a:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     79c:	92 8d       	ldd	r25, Z+26	; 0x1a
     79e:	9f 5f       	subi	r25, 0xFF	; 255
     7a0:	9f 73       	andi	r25, 0x3F	; 63
     7a2:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
     7a4:	90 e0       	ldi	r25, 0x00	; 0
     7a6:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     7a8:	8f ef       	ldi	r24, 0xFF	; 255
     7aa:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     7ac:	08 95       	ret

000007ae <_ZN14HardwareSerial17availableForWriteEv>:
{
#if (SERIAL_TX_BUFFER_SIZE>256)
  uint8_t oldSREG = SREG;
  cli();
#endif
  tx_buffer_index_t head = _tx_buffer_head;
     7ae:	fc 01       	movw	r30, r24
     7b0:	53 8d       	ldd	r21, Z+27	; 0x1b
  tx_buffer_index_t tail = _tx_buffer_tail;
     7b2:	44 8d       	ldd	r20, Z+28	; 0x1c
     7b4:	25 2f       	mov	r18, r21
     7b6:	30 e0       	ldi	r19, 0x00	; 0
     7b8:	84 2f       	mov	r24, r20
     7ba:	90 e0       	ldi	r25, 0x00	; 0
#if (SERIAL_TX_BUFFER_SIZE>256)
  SREG = oldSREG;
#endif
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     7bc:	82 1b       	sub	r24, r18
     7be:	93 0b       	sbc	r25, r19
     7c0:	54 17       	cp	r21, r20
     7c2:	10 f0       	brcs	.+4      	; 0x7c8 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
     7c4:	cf 96       	adiw	r24, 0x3f	; 63
     7c6:	08 95       	ret
  return tail - head - 1;
     7c8:	01 97       	sbiw	r24, 0x01	; 1
}
     7ca:	08 95       	ret

000007cc <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     7cc:	8b e3       	ldi	r24, 0x3B	; 59
     7ce:	95 e0       	ldi	r25, 0x05	; 5
     7d0:	89 2b       	or	r24, r25
     7d2:	49 f0       	breq	.+18     	; 0x7e6 <_Z14serialEventRunv+0x1a>
     7d4:	80 e0       	ldi	r24, 0x00	; 0
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	89 2b       	or	r24, r25
     7da:	29 f0       	breq	.+10     	; 0x7e6 <_Z14serialEventRunv+0x1a>
     7dc:	0e 94 3b 05 	call	0xa76	; 0xa76 <_Z17Serial0_availablev>
     7e0:	81 11       	cpse	r24, r1
     7e2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
     7e6:	08 95       	ret

000007e8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     7e8:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     7ea:	84 8d       	ldd	r24, Z+28	; 0x1c
     7ec:	df 01       	movw	r26, r30
     7ee:	a8 0f       	add	r26, r24
     7f0:	b1 1d       	adc	r27, r1
     7f2:	a3 5a       	subi	r26, 0xA3	; 163
     7f4:	bf 4f       	sbci	r27, 0xFF	; 255
     7f6:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     7f8:	84 8d       	ldd	r24, Z+28	; 0x1c
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	01 96       	adiw	r24, 0x01	; 1
     7fe:	8f 73       	andi	r24, 0x3F	; 63
     800:	99 27       	eor	r25, r25
     802:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
     804:	a6 89       	ldd	r26, Z+22	; 0x16
     806:	b7 89       	ldd	r27, Z+23	; 0x17
     808:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
     80a:	a0 89       	ldd	r26, Z+16	; 0x10
     80c:	b1 89       	ldd	r27, Z+17	; 0x11
     80e:	8c 91       	ld	r24, X
     810:	80 64       	ori	r24, 0x40	; 64
     812:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
     814:	93 8d       	ldd	r25, Z+27	; 0x1b
     816:	84 8d       	ldd	r24, Z+28	; 0x1c
     818:	98 13       	cpse	r25, r24
     81a:	06 c0       	rjmp	.+12     	; 0x828 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     81c:	02 88       	ldd	r0, Z+18	; 0x12
     81e:	f3 89       	ldd	r31, Z+19	; 0x13
     820:	e0 2d       	mov	r30, r0
     822:	80 81       	ld	r24, Z
     824:	8f 7d       	andi	r24, 0xDF	; 223
     826:	80 83       	st	Z, r24
     828:	08 95       	ret

0000082a <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     82a:	ef 92       	push	r14
     82c:	ff 92       	push	r15
     82e:	0f 93       	push	r16
     830:	1f 93       	push	r17
     832:	cf 93       	push	r28
     834:	df 93       	push	r29
     836:	ec 01       	movw	r28, r24
  _written = true;
     838:	81 e0       	ldi	r24, 0x01	; 1
     83a:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     83c:	9b 8d       	ldd	r25, Y+27	; 0x1b
     83e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     840:	98 13       	cpse	r25, r24
     842:	05 c0       	rjmp	.+10     	; 0x84e <_ZN14HardwareSerial5writeEh+0x24>
     844:	e8 89       	ldd	r30, Y+16	; 0x10
     846:	f9 89       	ldd	r31, Y+17	; 0x11
     848:	80 81       	ld	r24, Z
     84a:	85 fd       	sbrc	r24, 5
     84c:	24 c0       	rjmp	.+72     	; 0x896 <_ZN14HardwareSerial5writeEh+0x6c>
     84e:	f6 2e       	mov	r15, r22
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     850:	0b 8d       	ldd	r16, Y+27	; 0x1b
     852:	10 e0       	ldi	r17, 0x00	; 0
     854:	0f 5f       	subi	r16, 0xFF	; 255
     856:	1f 4f       	sbci	r17, 0xFF	; 255
     858:	0f 73       	andi	r16, 0x3F	; 63
     85a:	11 27       	eor	r17, r17
     85c:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     85e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     860:	e8 12       	cpse	r14, r24
     862:	0c c0       	rjmp	.+24     	; 0x87c <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
     864:	0f b6       	in	r0, 0x3f	; 63
     866:	07 fc       	sbrc	r0, 7
     868:	fa cf       	rjmp	.-12     	; 0x85e <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     86a:	e8 89       	ldd	r30, Y+16	; 0x10
     86c:	f9 89       	ldd	r31, Y+17	; 0x11
     86e:	80 81       	ld	r24, Z
     870:	85 ff       	sbrs	r24, 5
     872:	f5 cf       	rjmp	.-22     	; 0x85e <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
     874:	ce 01       	movw	r24, r28
     876:	0e 94 f4 03 	call	0x7e8	; 0x7e8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     87a:	f1 cf       	rjmp	.-30     	; 0x85e <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     87c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     87e:	fe 01       	movw	r30, r28
     880:	e8 0f       	add	r30, r24
     882:	f1 1d       	adc	r31, r1
     884:	e3 5a       	subi	r30, 0xA3	; 163
     886:	ff 4f       	sbci	r31, 0xFF	; 255
     888:	f0 82       	st	Z, r15
  _tx_buffer_head = i;
     88a:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
     88c:	ea 89       	ldd	r30, Y+18	; 0x12
     88e:	fb 89       	ldd	r31, Y+19	; 0x13
     890:	80 81       	ld	r24, Z
     892:	80 62       	ori	r24, 0x20	; 32
     894:	07 c0       	rjmp	.+14     	; 0x8a4 <_ZN14HardwareSerial5writeEh+0x7a>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
     896:	ee 89       	ldd	r30, Y+22	; 0x16
     898:	ff 89       	ldd	r31, Y+23	; 0x17
     89a:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
     89c:	e8 89       	ldd	r30, Y+16	; 0x10
     89e:	f9 89       	ldd	r31, Y+17	; 0x11
     8a0:	80 81       	ld	r24, Z
     8a2:	80 64       	ori	r24, 0x40	; 64
     8a4:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	90 e0       	ldi	r25, 0x00	; 0
     8aa:	df 91       	pop	r29
     8ac:	cf 91       	pop	r28
     8ae:	1f 91       	pop	r17
     8b0:	0f 91       	pop	r16
     8b2:	ff 90       	pop	r15
     8b4:	ef 90       	pop	r14
     8b6:	08 95       	ret

000008b8 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     8b8:	cf 93       	push	r28
     8ba:	df 93       	push	r29
     8bc:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     8be:	88 8d       	ldd	r24, Y+24	; 0x18
     8c0:	88 23       	and	r24, r24
     8c2:	c9 f0       	breq	.+50     	; 0x8f6 <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     8c4:	ea 89       	ldd	r30, Y+18	; 0x12
     8c6:	fb 89       	ldd	r31, Y+19	; 0x13
     8c8:	80 81       	ld	r24, Z
     8ca:	85 fd       	sbrc	r24, 5
     8cc:	05 c0       	rjmp	.+10     	; 0x8d8 <_ZN14HardwareSerial5flushEv+0x20>
     8ce:	a8 89       	ldd	r26, Y+16	; 0x10
     8d0:	b9 89       	ldd	r27, Y+17	; 0x11
     8d2:	8c 91       	ld	r24, X
     8d4:	86 fd       	sbrc	r24, 6
     8d6:	0f c0       	rjmp	.+30     	; 0x8f6 <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     8d8:	0f b6       	in	r0, 0x3f	; 63
     8da:	07 fc       	sbrc	r0, 7
     8dc:	f5 cf       	rjmp	.-22     	; 0x8c8 <_ZN14HardwareSerial5flushEv+0x10>
     8de:	80 81       	ld	r24, Z
     8e0:	85 ff       	sbrs	r24, 5
     8e2:	f2 cf       	rjmp	.-28     	; 0x8c8 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     8e4:	a8 89       	ldd	r26, Y+16	; 0x10
     8e6:	b9 89       	ldd	r27, Y+17	; 0x11
     8e8:	8c 91       	ld	r24, X
     8ea:	85 ff       	sbrs	r24, 5
     8ec:	ed cf       	rjmp	.-38     	; 0x8c8 <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
     8ee:	ce 01       	movw	r24, r28
     8f0:	0e 94 f4 03 	call	0x7e8	; 0x7e8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     8f4:	e7 cf       	rjmp	.-50     	; 0x8c4 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     8f6:	df 91       	pop	r29
     8f8:	cf 91       	pop	r28
     8fa:	08 95       	ret

000008fc <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
     8fc:	cf 92       	push	r12
     8fe:	df 92       	push	r13
     900:	ef 92       	push	r14
     902:	ff 92       	push	r15
     904:	1f 93       	push	r17
     906:	cf 93       	push	r28
     908:	df 93       	push	r29
     90a:	ec 01       	movw	r28, r24
     90c:	6a 01       	movw	r12, r20
     90e:	7b 01       	movw	r14, r22
     910:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
     912:	e8 89       	ldd	r30, Y+16	; 0x10
     914:	f9 89       	ldd	r31, Y+17	; 0x11
     916:	82 e0       	ldi	r24, 0x02	; 2
     918:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     91a:	41 15       	cp	r20, r1
     91c:	51 4e       	sbci	r21, 0xE1	; 225
     91e:	61 05       	cpc	r22, r1
     920:	71 05       	cpc	r23, r1
     922:	b1 f0       	breq	.+44     	; 0x950 <__stack+0x51>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
     924:	60 e0       	ldi	r22, 0x00	; 0
     926:	79 e0       	ldi	r23, 0x09	; 9
     928:	8d e3       	ldi	r24, 0x3D	; 61
     92a:	90 e0       	ldi	r25, 0x00	; 0
     92c:	a7 01       	movw	r20, r14
     92e:	96 01       	movw	r18, r12
     930:	0e 94 d5 07 	call	0xfaa	; 0xfaa <__udivmodsi4>
     934:	da 01       	movw	r26, r20
     936:	c9 01       	movw	r24, r18
     938:	01 97       	sbiw	r24, 0x01	; 1
     93a:	a1 09       	sbc	r26, r1
     93c:	b1 09       	sbc	r27, r1
     93e:	b6 95       	lsr	r27
     940:	a7 95       	ror	r26
     942:	97 95       	ror	r25
     944:	87 95       	ror	r24
     946:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     948:	21 15       	cp	r18, r1
     94a:	80 e1       	ldi	r24, 0x10	; 16
     94c:	38 07       	cpc	r19, r24
     94e:	a8 f0       	brcs	.+42     	; 0x97a <__stack+0x7b>
  {
    *_ucsra = 0;
     950:	e8 89       	ldd	r30, Y+16	; 0x10
     952:	f9 89       	ldd	r31, Y+17	; 0x11
     954:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
     956:	60 e8       	ldi	r22, 0x80	; 128
     958:	74 e8       	ldi	r23, 0x84	; 132
     95a:	8e e1       	ldi	r24, 0x1E	; 30
     95c:	90 e0       	ldi	r25, 0x00	; 0
     95e:	a7 01       	movw	r20, r14
     960:	96 01       	movw	r18, r12
     962:	0e 94 d5 07 	call	0xfaa	; 0xfaa <__udivmodsi4>
     966:	da 01       	movw	r26, r20
     968:	c9 01       	movw	r24, r18
     96a:	01 97       	sbiw	r24, 0x01	; 1
     96c:	a1 09       	sbc	r26, r1
     96e:	b1 09       	sbc	r27, r1
     970:	b6 95       	lsr	r27
     972:	a7 95       	ror	r26
     974:	97 95       	ror	r25
     976:	87 95       	ror	r24
     978:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     97a:	ec 85       	ldd	r30, Y+12	; 0x0c
     97c:	fd 85       	ldd	r31, Y+13	; 0x0d
     97e:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
     980:	ee 85       	ldd	r30, Y+14	; 0x0e
     982:	ff 85       	ldd	r31, Y+15	; 0x0f
     984:	20 83       	st	Z, r18

  _written = false;
     986:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
     988:	ec 89       	ldd	r30, Y+20	; 0x14
     98a:	fd 89       	ldd	r31, Y+21	; 0x15
     98c:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
     98e:	ea 89       	ldd	r30, Y+18	; 0x12
     990:	fb 89       	ldd	r31, Y+19	; 0x13
     992:	80 81       	ld	r24, Z
     994:	80 61       	ori	r24, 0x10	; 16
     996:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
     998:	ea 89       	ldd	r30, Y+18	; 0x12
     99a:	fb 89       	ldd	r31, Y+19	; 0x13
     99c:	80 81       	ld	r24, Z
     99e:	88 60       	ori	r24, 0x08	; 8
     9a0:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
     9a2:	ea 89       	ldd	r30, Y+18	; 0x12
     9a4:	fb 89       	ldd	r31, Y+19	; 0x13
     9a6:	80 81       	ld	r24, Z
     9a8:	80 68       	ori	r24, 0x80	; 128
     9aa:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
     9ac:	ea 89       	ldd	r30, Y+18	; 0x12
     9ae:	fb 89       	ldd	r31, Y+19	; 0x13
     9b0:	80 81       	ld	r24, Z
     9b2:	8f 7d       	andi	r24, 0xDF	; 223
     9b4:	80 83       	st	Z, r24
}
     9b6:	df 91       	pop	r29
     9b8:	cf 91       	pop	r28
     9ba:	1f 91       	pop	r17
     9bc:	ff 90       	pop	r15
     9be:	ef 90       	pop	r14
     9c0:	df 90       	pop	r13
     9c2:	cf 90       	pop	r12
     9c4:	08 95       	ret

000009c6 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
     9c6:	1f 92       	push	r1
     9c8:	0f 92       	push	r0
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	0f 92       	push	r0
     9ce:	11 24       	eor	r1, r1
     9d0:	2f 93       	push	r18
     9d2:	8f 93       	push	r24
     9d4:	9f 93       	push	r25
     9d6:	ef 93       	push	r30
     9d8:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
     9da:	e0 91 25 02 	lds	r30, 0x0225	; 0x800225 <Serial+0x10>
     9de:	f0 91 26 02 	lds	r31, 0x0226	; 0x800226 <Serial+0x11>
     9e2:	80 81       	ld	r24, Z
     9e4:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <Serial+0x16>
     9e8:	f0 91 2c 02 	lds	r31, 0x022C	; 0x80022c <Serial+0x17>
     9ec:	82 fd       	sbrc	r24, 2
     9ee:	12 c0       	rjmp	.+36     	; 0xa14 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
     9f0:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     9f2:	80 91 2e 02 	lds	r24, 0x022E	; 0x80022e <Serial+0x19>
     9f6:	8f 5f       	subi	r24, 0xFF	; 255
     9f8:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     9fa:	20 91 2f 02 	lds	r18, 0x022F	; 0x80022f <Serial+0x1a>
     9fe:	82 17       	cp	r24, r18
     a00:	51 f0       	breq	.+20     	; 0xa16 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
     a02:	e0 91 2e 02 	lds	r30, 0x022E	; 0x80022e <Serial+0x19>
     a06:	f0 e0       	ldi	r31, 0x00	; 0
     a08:	eb 5e       	subi	r30, 0xEB	; 235
     a0a:	fd 4f       	sbci	r31, 0xFD	; 253
     a0c:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
     a0e:	80 93 2e 02 	sts	0x022E, r24	; 0x80022e <Serial+0x19>
     a12:	01 c0       	rjmp	.+2      	; 0xa16 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
     a14:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
     a16:	ff 91       	pop	r31
     a18:	ef 91       	pop	r30
     a1a:	9f 91       	pop	r25
     a1c:	8f 91       	pop	r24
     a1e:	2f 91       	pop	r18
     a20:	0f 90       	pop	r0
     a22:	0f be       	out	0x3f, r0	; 63
     a24:	0f 90       	pop	r0
     a26:	1f 90       	pop	r1
     a28:	18 95       	reti

00000a2a <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
     a2a:	1f 92       	push	r1
     a2c:	0f 92       	push	r0
     a2e:	0f b6       	in	r0, 0x3f	; 63
     a30:	0f 92       	push	r0
     a32:	11 24       	eor	r1, r1
     a34:	2f 93       	push	r18
     a36:	3f 93       	push	r19
     a38:	4f 93       	push	r20
     a3a:	5f 93       	push	r21
     a3c:	6f 93       	push	r22
     a3e:	7f 93       	push	r23
     a40:	8f 93       	push	r24
     a42:	9f 93       	push	r25
     a44:	af 93       	push	r26
     a46:	bf 93       	push	r27
     a48:	ef 93       	push	r30
     a4a:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
     a4c:	85 e1       	ldi	r24, 0x15	; 21
     a4e:	92 e0       	ldi	r25, 0x02	; 2
     a50:	0e 94 f4 03 	call	0x7e8	; 0x7e8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
     a54:	ff 91       	pop	r31
     a56:	ef 91       	pop	r30
     a58:	bf 91       	pop	r27
     a5a:	af 91       	pop	r26
     a5c:	9f 91       	pop	r25
     a5e:	8f 91       	pop	r24
     a60:	7f 91       	pop	r23
     a62:	6f 91       	pop	r22
     a64:	5f 91       	pop	r21
     a66:	4f 91       	pop	r20
     a68:	3f 91       	pop	r19
     a6a:	2f 91       	pop	r18
     a6c:	0f 90       	pop	r0
     a6e:	0f be       	out	0x3f, r0	; 63
     a70:	0f 90       	pop	r0
     a72:	1f 90       	pop	r1
     a74:	18 95       	reti

00000a76 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     a76:	85 e1       	ldi	r24, 0x15	; 21
     a78:	92 e0       	ldi	r25, 0x02	; 2
     a7a:	0e 94 a9 03 	call	0x752	; 0x752 <_ZN14HardwareSerial9availableEv>
     a7e:	21 e0       	ldi	r18, 0x01	; 1
     a80:	89 2b       	or	r24, r25
     a82:	09 f4       	brne	.+2      	; 0xa86 <_Z17Serial0_availablev+0x10>
     a84:	20 e0       	ldi	r18, 0x00	; 0
}
     a86:	82 2f       	mov	r24, r18
     a88:	08 95       	ret

00000a8a <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     a8a:	e5 e1       	ldi	r30, 0x15	; 21
     a8c:	f2 e0       	ldi	r31, 0x02	; 2
     a8e:	13 82       	std	Z+3, r1	; 0x03
     a90:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
     a92:	88 ee       	ldi	r24, 0xE8	; 232
     a94:	93 e0       	ldi	r25, 0x03	; 3
     a96:	a0 e0       	ldi	r26, 0x00	; 0
     a98:	b0 e0       	ldi	r27, 0x00	; 0
     a9a:	84 83       	std	Z+4, r24	; 0x04
     a9c:	95 83       	std	Z+5, r25	; 0x05
     a9e:	a6 83       	std	Z+6, r26	; 0x06
     aa0:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
     aa2:	87 ef       	ldi	r24, 0xF7	; 247
     aa4:	91 e0       	ldi	r25, 0x01	; 1
     aa6:	91 83       	std	Z+1, r25	; 0x01
     aa8:	80 83       	st	Z, r24
     aaa:	85 ec       	ldi	r24, 0xC5	; 197
     aac:	90 e0       	ldi	r25, 0x00	; 0
     aae:	95 87       	std	Z+13, r25	; 0x0d
     ab0:	84 87       	std	Z+12, r24	; 0x0c
     ab2:	84 ec       	ldi	r24, 0xC4	; 196
     ab4:	90 e0       	ldi	r25, 0x00	; 0
     ab6:	97 87       	std	Z+15, r25	; 0x0f
     ab8:	86 87       	std	Z+14, r24	; 0x0e
     aba:	80 ec       	ldi	r24, 0xC0	; 192
     abc:	90 e0       	ldi	r25, 0x00	; 0
     abe:	91 8b       	std	Z+17, r25	; 0x11
     ac0:	80 8b       	std	Z+16, r24	; 0x10
     ac2:	81 ec       	ldi	r24, 0xC1	; 193
     ac4:	90 e0       	ldi	r25, 0x00	; 0
     ac6:	93 8b       	std	Z+19, r25	; 0x13
     ac8:	82 8b       	std	Z+18, r24	; 0x12
     aca:	82 ec       	ldi	r24, 0xC2	; 194
     acc:	90 e0       	ldi	r25, 0x00	; 0
     ace:	95 8b       	std	Z+21, r25	; 0x15
     ad0:	84 8b       	std	Z+20, r24	; 0x14
     ad2:	86 ec       	ldi	r24, 0xC6	; 198
     ad4:	90 e0       	ldi	r25, 0x00	; 0
     ad6:	97 8b       	std	Z+23, r25	; 0x17
     ad8:	86 8b       	std	Z+22, r24	; 0x16
     ada:	11 8e       	std	Z+25, r1	; 0x19
     adc:	12 8e       	std	Z+26, r1	; 0x1a
     ade:	13 8e       	std	Z+27, r1	; 0x1b
     ae0:	14 8e       	std	Z+28, r1	; 0x1c
     ae2:	08 95       	ret

00000ae4 <initVariant>:
     ae4:	08 95       	ret

00000ae6 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
     ae6:	0e 94 d2 06 	call	0xda4	; 0xda4 <init>

	initVariant();
     aea:	0e 94 72 05 	call	0xae4	; 0xae4 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
     aee:	0e 94 fe 00 	call	0x1fc	; 0x1fc <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
     af2:	c6 ee       	ldi	r28, 0xE6	; 230
     af4:	d3 e0       	ldi	r29, 0x03	; 3
#endif
	
	setup();
    
	for (;;) {
		loop();
     af6:	0e 94 48 01 	call	0x290	; 0x290 <loop>
		if (serialEventRun) serialEventRun();
     afa:	20 97       	sbiw	r28, 0x00	; 0
     afc:	e1 f3       	breq	.-8      	; 0xaf6 <main+0x10>
     afe:	0e 94 e6 03 	call	0x7cc	; 0x7cc <_Z14serialEventRunv>
     b02:	f9 cf       	rjmp	.-14     	; 0xaf6 <main+0x10>

00000b04 <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
     b04:	cf 92       	push	r12
     b06:	df 92       	push	r13
     b08:	ef 92       	push	r14
     b0a:	ff 92       	push	r15
     b0c:	0f 93       	push	r16
     b0e:	1f 93       	push	r17
     b10:	cf 93       	push	r28
     b12:	df 93       	push	r29
     b14:	6c 01       	movw	r12, r24
     b16:	7a 01       	movw	r14, r20
     b18:	8b 01       	movw	r16, r22
     b1a:	c0 e0       	ldi	r28, 0x00	; 0
     b1c:	d0 e0       	ldi	r29, 0x00	; 0
     b1e:	ce 15       	cp	r28, r14
     b20:	df 05       	cpc	r29, r15
     b22:	81 f0       	breq	.+32     	; 0xb44 <_ZN5Print5writeEPKhj+0x40>
     b24:	d8 01       	movw	r26, r16
     b26:	6d 91       	ld	r22, X+
     b28:	8d 01       	movw	r16, r26
     b2a:	d6 01       	movw	r26, r12
     b2c:	ed 91       	ld	r30, X+
     b2e:	fc 91       	ld	r31, X
     b30:	01 90       	ld	r0, Z+
     b32:	f0 81       	ld	r31, Z
     b34:	e0 2d       	mov	r30, r0
     b36:	c6 01       	movw	r24, r12
     b38:	09 95       	icall
     b3a:	89 2b       	or	r24, r25
     b3c:	11 f0       	breq	.+4      	; 0xb42 <_ZN5Print5writeEPKhj+0x3e>
     b3e:	21 96       	adiw	r28, 0x01	; 1
     b40:	ee cf       	rjmp	.-36     	; 0xb1e <_ZN5Print5writeEPKhj+0x1a>
     b42:	7e 01       	movw	r14, r28
     b44:	c7 01       	movw	r24, r14
     b46:	df 91       	pop	r29
     b48:	cf 91       	pop	r28
     b4a:	1f 91       	pop	r17
     b4c:	0f 91       	pop	r16
     b4e:	ff 90       	pop	r15
     b50:	ef 90       	pop	r14
     b52:	df 90       	pop	r13
     b54:	cf 90       	pop	r12
     b56:	08 95       	ret

00000b58 <_ZN5Print5writeEPKc>:
     b58:	61 15       	cp	r22, r1
     b5a:	71 05       	cpc	r23, r1
     b5c:	79 f0       	breq	.+30     	; 0xb7c <_ZN5Print5writeEPKc+0x24>
     b5e:	fb 01       	movw	r30, r22
     b60:	01 90       	ld	r0, Z+
     b62:	00 20       	and	r0, r0
     b64:	e9 f7       	brne	.-6      	; 0xb60 <_ZN5Print5writeEPKc+0x8>
     b66:	31 97       	sbiw	r30, 0x01	; 1
     b68:	af 01       	movw	r20, r30
     b6a:	46 1b       	sub	r20, r22
     b6c:	57 0b       	sbc	r21, r23
     b6e:	dc 01       	movw	r26, r24
     b70:	ed 91       	ld	r30, X+
     b72:	fc 91       	ld	r31, X
     b74:	02 80       	ldd	r0, Z+2	; 0x02
     b76:	f3 81       	ldd	r31, Z+3	; 0x03
     b78:	e0 2d       	mov	r30, r0
     b7a:	09 94       	ijmp
     b7c:	80 e0       	ldi	r24, 0x00	; 0
     b7e:	90 e0       	ldi	r25, 0x00	; 0
     b80:	08 95       	ret

00000b82 <_ZN5Print5printEc>:
     b82:	dc 01       	movw	r26, r24
     b84:	ed 91       	ld	r30, X+
     b86:	fc 91       	ld	r31, X
     b88:	01 90       	ld	r0, Z+
     b8a:	f0 81       	ld	r31, Z
     b8c:	e0 2d       	mov	r30, r0
     b8e:	09 94       	ijmp

00000b90 <_ZN5Print7printlnEv>:
     b90:	65 e0       	ldi	r22, 0x05	; 5
     b92:	72 e0       	ldi	r23, 0x02	; 2
     b94:	0c 94 ac 05 	jmp	0xb58	; 0xb58 <_ZN5Print5writeEPKc>

00000b98 <_ZN5Print7printlnEPKc>:
     b98:	0f 93       	push	r16
     b9a:	1f 93       	push	r17
     b9c:	cf 93       	push	r28
     b9e:	df 93       	push	r29
     ba0:	ec 01       	movw	r28, r24
     ba2:	0e 94 ac 05 	call	0xb58	; 0xb58 <_ZN5Print5writeEPKc>
     ba6:	8c 01       	movw	r16, r24
     ba8:	ce 01       	movw	r24, r28
     baa:	0e 94 c8 05 	call	0xb90	; 0xb90 <_ZN5Print7printlnEv>
     bae:	80 0f       	add	r24, r16
     bb0:	91 1f       	adc	r25, r17
     bb2:	df 91       	pop	r29
     bb4:	cf 91       	pop	r28
     bb6:	1f 91       	pop	r17
     bb8:	0f 91       	pop	r16
     bba:	08 95       	ret

00000bbc <_ZN5Print11printNumberEmh>:
     bbc:	8f 92       	push	r8
     bbe:	9f 92       	push	r9
     bc0:	af 92       	push	r10
     bc2:	bf 92       	push	r11
     bc4:	ef 92       	push	r14
     bc6:	ff 92       	push	r15
     bc8:	0f 93       	push	r16
     bca:	1f 93       	push	r17
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	cd b7       	in	r28, 0x3d	; 61
     bd2:	de b7       	in	r29, 0x3e	; 62
     bd4:	a1 97       	sbiw	r28, 0x21	; 33
     bd6:	0f b6       	in	r0, 0x3f	; 63
     bd8:	f8 94       	cli
     bda:	de bf       	out	0x3e, r29	; 62
     bdc:	0f be       	out	0x3f, r0	; 63
     bde:	cd bf       	out	0x3d, r28	; 61
     be0:	7c 01       	movw	r14, r24
     be2:	fa 01       	movw	r30, r20
     be4:	cb 01       	movw	r24, r22
     be6:	19 a2       	std	Y+33, r1	; 0x21
     be8:	22 30       	cpi	r18, 0x02	; 2
     bea:	08 f4       	brcc	.+2      	; 0xbee <_ZN5Print11printNumberEmh+0x32>
     bec:	2a e0       	ldi	r18, 0x0A	; 10
     bee:	8e 01       	movw	r16, r28
     bf0:	0f 5d       	subi	r16, 0xDF	; 223
     bf2:	1f 4f       	sbci	r17, 0xFF	; 255
     bf4:	82 2e       	mov	r8, r18
     bf6:	91 2c       	mov	r9, r1
     bf8:	a1 2c       	mov	r10, r1
     bfa:	b1 2c       	mov	r11, r1
     bfc:	bf 01       	movw	r22, r30
     bfe:	a5 01       	movw	r20, r10
     c00:	94 01       	movw	r18, r8
     c02:	0e 94 d5 07 	call	0xfaa	; 0xfaa <__udivmodsi4>
     c06:	f9 01       	movw	r30, r18
     c08:	ca 01       	movw	r24, r20
     c0a:	01 50       	subi	r16, 0x01	; 1
     c0c:	11 09       	sbc	r17, r1
     c0e:	6a 30       	cpi	r22, 0x0A	; 10
     c10:	10 f4       	brcc	.+4      	; 0xc16 <_ZN5Print11printNumberEmh+0x5a>
     c12:	60 5d       	subi	r22, 0xD0	; 208
     c14:	01 c0       	rjmp	.+2      	; 0xc18 <_ZN5Print11printNumberEmh+0x5c>
     c16:	69 5c       	subi	r22, 0xC9	; 201
     c18:	d8 01       	movw	r26, r16
     c1a:	6c 93       	st	X, r22
     c1c:	23 2b       	or	r18, r19
     c1e:	24 2b       	or	r18, r20
     c20:	25 2b       	or	r18, r21
     c22:	61 f7       	brne	.-40     	; 0xbfc <_ZN5Print11printNumberEmh+0x40>
     c24:	b8 01       	movw	r22, r16
     c26:	c7 01       	movw	r24, r14
     c28:	0e 94 ac 05 	call	0xb58	; 0xb58 <_ZN5Print5writeEPKc>
     c2c:	a1 96       	adiw	r28, 0x21	; 33
     c2e:	0f b6       	in	r0, 0x3f	; 63
     c30:	f8 94       	cli
     c32:	de bf       	out	0x3e, r29	; 62
     c34:	0f be       	out	0x3f, r0	; 63
     c36:	cd bf       	out	0x3d, r28	; 61
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	ff 90       	pop	r15
     c42:	ef 90       	pop	r14
     c44:	bf 90       	pop	r11
     c46:	af 90       	pop	r10
     c48:	9f 90       	pop	r9
     c4a:	8f 90       	pop	r8
     c4c:	08 95       	ret

00000c4e <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
     c4e:	cf 92       	push	r12
     c50:	df 92       	push	r13
     c52:	ef 92       	push	r14
     c54:	ff 92       	push	r15
     c56:	0f 93       	push	r16
     c58:	1f 93       	push	r17
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
  if (base == 0) {
     c5e:	21 15       	cp	r18, r1
     c60:	31 05       	cpc	r19, r1
     c62:	81 f4       	brne	.+32     	; 0xc84 <_ZN5Print5printEli+0x36>
    return write(n);
     c64:	dc 01       	movw	r26, r24
     c66:	ed 91       	ld	r30, X+
     c68:	fc 91       	ld	r31, X
     c6a:	01 90       	ld	r0, Z+
     c6c:	f0 81       	ld	r31, Z
     c6e:	e0 2d       	mov	r30, r0
     c70:	64 2f       	mov	r22, r20
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	1f 91       	pop	r17
     c78:	0f 91       	pop	r16
     c7a:	ff 90       	pop	r15
     c7c:	ef 90       	pop	r14
     c7e:	df 90       	pop	r13
     c80:	cf 90       	pop	r12
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
     c82:	09 94       	ijmp
  } else if (base == 10) {
     c84:	2a 30       	cpi	r18, 0x0A	; 10
     c86:	31 05       	cpc	r19, r1
     c88:	01 f5       	brne	.+64     	; 0xcca <_ZN5Print5printEli+0x7c>
    if (n < 0) {
     c8a:	77 ff       	sbrs	r23, 7
     c8c:	1d c0       	rjmp	.+58     	; 0xcc8 <_ZN5Print5printEli+0x7a>
     c8e:	6a 01       	movw	r12, r20
     c90:	7b 01       	movw	r14, r22
     c92:	ec 01       	movw	r28, r24
      int t = print('-');
     c94:	6d e2       	ldi	r22, 0x2D	; 45
     c96:	0e 94 c1 05 	call	0xb82	; 0xb82 <_ZN5Print5printEc>
     c9a:	8c 01       	movw	r16, r24
      n = -n;
      return printNumber(n, 10) + t;
     c9c:	44 27       	eor	r20, r20
     c9e:	55 27       	eor	r21, r21
     ca0:	ba 01       	movw	r22, r20
     ca2:	4c 19       	sub	r20, r12
     ca4:	5d 09       	sbc	r21, r13
     ca6:	6e 09       	sbc	r22, r14
     ca8:	7f 09       	sbc	r23, r15
     caa:	2a e0       	ldi	r18, 0x0A	; 10
     cac:	ce 01       	movw	r24, r28
     cae:	0e 94 de 05 	call	0xbbc	; 0xbbc <_ZN5Print11printNumberEmh>
     cb2:	80 0f       	add	r24, r16
     cb4:	91 1f       	adc	r25, r17
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
     cb6:	df 91       	pop	r29
     cb8:	cf 91       	pop	r28
     cba:	1f 91       	pop	r17
     cbc:	0f 91       	pop	r16
     cbe:	ff 90       	pop	r15
     cc0:	ef 90       	pop	r14
     cc2:	df 90       	pop	r13
     cc4:	cf 90       	pop	r12
     cc6:	08 95       	ret
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
     cc8:	2a e0       	ldi	r18, 0x0A	; 10
  } else {
    return printNumber(n, base);
  }
}
     cca:	df 91       	pop	r29
     ccc:	cf 91       	pop	r28
     cce:	1f 91       	pop	r17
     cd0:	0f 91       	pop	r16
     cd2:	ff 90       	pop	r15
     cd4:	ef 90       	pop	r14
     cd6:	df 90       	pop	r13
     cd8:	cf 90       	pop	r12
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
     cda:	0c 94 de 05 	jmp	0xbbc	; 0xbbc <_ZN5Print11printNumberEmh>

00000cde <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
     cde:	9a 01       	movw	r18, r20
  return print((long) n, base);
     ce0:	ab 01       	movw	r20, r22
     ce2:	77 0f       	add	r23, r23
     ce4:	66 0b       	sbc	r22, r22
     ce6:	77 0b       	sbc	r23, r23
     ce8:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <_ZN5Print5printEli>

00000cec <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
     cec:	0f 93       	push	r16
     cee:	1f 93       	push	r17
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
     cf4:	ec 01       	movw	r28, r24
  size_t n = print(num, base);
     cf6:	0e 94 6f 06 	call	0xcde	; 0xcde <_ZN5Print5printEii>
     cfa:	8c 01       	movw	r16, r24
  n += println();
     cfc:	ce 01       	movw	r24, r28
     cfe:	0e 94 c8 05 	call	0xb90	; 0xb90 <_ZN5Print7printlnEv>
  return n;
}
     d02:	80 0f       	add	r24, r16
     d04:	91 1f       	adc	r25, r17
     d06:	df 91       	pop	r29
     d08:	cf 91       	pop	r28
     d0a:	1f 91       	pop	r17
     d0c:	0f 91       	pop	r16
     d0e:	08 95       	ret

00000d10 <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
     d10:	1f 92       	push	r1
     d12:	0f 92       	push	r0
     d14:	0f b6       	in	r0, 0x3f	; 63
     d16:	0f 92       	push	r0
     d18:	11 24       	eor	r1, r1
     d1a:	2f 93       	push	r18
     d1c:	3f 93       	push	r19
     d1e:	8f 93       	push	r24
     d20:	9f 93       	push	r25
     d22:	af 93       	push	r26
     d24:	bf 93       	push	r27
     d26:	80 91 b3 02 	lds	r24, 0x02B3	; 0x8002b3 <timer0_millis>
     d2a:	90 91 b4 02 	lds	r25, 0x02B4	; 0x8002b4 <timer0_millis+0x1>
     d2e:	a0 91 b5 02 	lds	r26, 0x02B5	; 0x8002b5 <timer0_millis+0x2>
     d32:	b0 91 b6 02 	lds	r27, 0x02B6	; 0x8002b6 <timer0_millis+0x3>
     d36:	30 91 b2 02 	lds	r19, 0x02B2	; 0x8002b2 <timer0_fract>
     d3a:	23 e0       	ldi	r18, 0x03	; 3
     d3c:	23 0f       	add	r18, r19
     d3e:	2d 37       	cpi	r18, 0x7D	; 125
     d40:	20 f4       	brcc	.+8      	; 0xd4a <__vector_16+0x3a>
     d42:	01 96       	adiw	r24, 0x01	; 1
     d44:	a1 1d       	adc	r26, r1
     d46:	b1 1d       	adc	r27, r1
     d48:	05 c0       	rjmp	.+10     	; 0xd54 <__vector_16+0x44>
     d4a:	26 e8       	ldi	r18, 0x86	; 134
     d4c:	23 0f       	add	r18, r19
     d4e:	02 96       	adiw	r24, 0x02	; 2
     d50:	a1 1d       	adc	r26, r1
     d52:	b1 1d       	adc	r27, r1
     d54:	20 93 b2 02 	sts	0x02B2, r18	; 0x8002b2 <timer0_fract>
     d58:	80 93 b3 02 	sts	0x02B3, r24	; 0x8002b3 <timer0_millis>
     d5c:	90 93 b4 02 	sts	0x02B4, r25	; 0x8002b4 <timer0_millis+0x1>
     d60:	a0 93 b5 02 	sts	0x02B5, r26	; 0x8002b5 <timer0_millis+0x2>
     d64:	b0 93 b6 02 	sts	0x02B6, r27	; 0x8002b6 <timer0_millis+0x3>
     d68:	80 91 b7 02 	lds	r24, 0x02B7	; 0x8002b7 <timer0_overflow_count>
     d6c:	90 91 b8 02 	lds	r25, 0x02B8	; 0x8002b8 <timer0_overflow_count+0x1>
     d70:	a0 91 b9 02 	lds	r26, 0x02B9	; 0x8002b9 <timer0_overflow_count+0x2>
     d74:	b0 91 ba 02 	lds	r27, 0x02BA	; 0x8002ba <timer0_overflow_count+0x3>
     d78:	01 96       	adiw	r24, 0x01	; 1
     d7a:	a1 1d       	adc	r26, r1
     d7c:	b1 1d       	adc	r27, r1
     d7e:	80 93 b7 02 	sts	0x02B7, r24	; 0x8002b7 <timer0_overflow_count>
     d82:	90 93 b8 02 	sts	0x02B8, r25	; 0x8002b8 <timer0_overflow_count+0x1>
     d86:	a0 93 b9 02 	sts	0x02B9, r26	; 0x8002b9 <timer0_overflow_count+0x2>
     d8a:	b0 93 ba 02 	sts	0x02BA, r27	; 0x8002ba <timer0_overflow_count+0x3>
     d8e:	bf 91       	pop	r27
     d90:	af 91       	pop	r26
     d92:	9f 91       	pop	r25
     d94:	8f 91       	pop	r24
     d96:	3f 91       	pop	r19
     d98:	2f 91       	pop	r18
     d9a:	0f 90       	pop	r0
     d9c:	0f be       	out	0x3f, r0	; 63
     d9e:	0f 90       	pop	r0
     da0:	1f 90       	pop	r1
     da2:	18 95       	reti

00000da4 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     da4:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     da6:	84 b5       	in	r24, 0x24	; 36
     da8:	82 60       	ori	r24, 0x02	; 2
     daa:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
     dac:	84 b5       	in	r24, 0x24	; 36
     dae:	81 60       	ori	r24, 0x01	; 1
     db0:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     db2:	85 b5       	in	r24, 0x25	; 37
     db4:	82 60       	ori	r24, 0x02	; 2
     db6:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
     db8:	85 b5       	in	r24, 0x25	; 37
     dba:	81 60       	ori	r24, 0x01	; 1
     dbc:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     dbe:	ee e6       	ldi	r30, 0x6E	; 110
     dc0:	f0 e0       	ldi	r31, 0x00	; 0
     dc2:	80 81       	ld	r24, Z
     dc4:	81 60       	ori	r24, 0x01	; 1
     dc6:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     dc8:	e1 e8       	ldi	r30, 0x81	; 129
     dca:	f0 e0       	ldi	r31, 0x00	; 0
     dcc:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     dce:	80 81       	ld	r24, Z
     dd0:	82 60       	ori	r24, 0x02	; 2
     dd2:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     dd4:	80 81       	ld	r24, Z
     dd6:	81 60       	ori	r24, 0x01	; 1
     dd8:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     dda:	e0 e8       	ldi	r30, 0x80	; 128
     ddc:	f0 e0       	ldi	r31, 0x00	; 0
     dde:	80 81       	ld	r24, Z
     de0:	81 60       	ori	r24, 0x01	; 1
     de2:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     de4:	e1 eb       	ldi	r30, 0xB1	; 177
     de6:	f0 e0       	ldi	r31, 0x00	; 0
     de8:	80 81       	ld	r24, Z
     dea:	84 60       	ori	r24, 0x04	; 4
     dec:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     dee:	e0 eb       	ldi	r30, 0xB0	; 176
     df0:	f0 e0       	ldi	r31, 0x00	; 0
     df2:	80 81       	ld	r24, Z
     df4:	81 60       	ori	r24, 0x01	; 1
     df6:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
     df8:	ea e7       	ldi	r30, 0x7A	; 122
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	80 81       	ld	r24, Z
     dfe:	84 60       	ori	r24, 0x04	; 4
     e00:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
     e02:	80 81       	ld	r24, Z
     e04:	82 60       	ori	r24, 0x02	; 2
     e06:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
     e08:	80 81       	ld	r24, Z
     e0a:	81 60       	ori	r24, 0x01	; 1
     e0c:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     e0e:	80 81       	ld	r24, Z
     e10:	80 68       	ori	r24, 0x80	; 128
     e12:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     e14:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     e18:	08 95       	ret

00000e1a <analogReference>:
void analogReference(uint8_t mode)
{
	// can't actually set the register here because the default setting
	// will connect AVCC and the AREF pin, which would cause a short if
	// there's something connected to AREF.
	analog_reference = mode;
     e1a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     e1e:	08 95       	ret

00000e20 <analogRead>:
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
     e20:	8e 30       	cpi	r24, 0x0E	; 14
     e22:	08 f0       	brcs	.+2      	; 0xe26 <analogRead+0x6>
     e24:	8e 50       	subi	r24, 0x0E	; 14
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
     e26:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
     e2a:	90 e4       	ldi	r25, 0x40	; 64
     e2c:	29 9f       	mul	r18, r25
     e2e:	90 01       	movw	r18, r0
     e30:	11 24       	eor	r1, r1
     e32:	87 70       	andi	r24, 0x07	; 7
     e34:	82 2b       	or	r24, r18
     e36:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
     e3a:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
     e3e:	80 64       	ori	r24, 0x40	; 64
     e40:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
     e44:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
     e48:	86 fd       	sbrc	r24, 6
     e4a:	fc cf       	rjmp	.-8      	; 0xe44 <analogRead+0x24>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
     e4c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
	high = ADCH;
     e50:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
     e54:	90 e0       	ldi	r25, 0x00	; 0
}
     e56:	92 2b       	or	r25, r18
     e58:	08 95       	ret

00000e5a <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     e5a:	83 30       	cpi	r24, 0x03	; 3
     e5c:	81 f0       	breq	.+32     	; 0xe7e <turnOffPWM+0x24>
     e5e:	28 f4       	brcc	.+10     	; 0xe6a <turnOffPWM+0x10>
     e60:	81 30       	cpi	r24, 0x01	; 1
     e62:	99 f0       	breq	.+38     	; 0xe8a <turnOffPWM+0x30>
     e64:	82 30       	cpi	r24, 0x02	; 2
     e66:	a1 f0       	breq	.+40     	; 0xe90 <turnOffPWM+0x36>
     e68:	08 95       	ret
     e6a:	87 30       	cpi	r24, 0x07	; 7
     e6c:	a9 f0       	breq	.+42     	; 0xe98 <turnOffPWM+0x3e>
     e6e:	88 30       	cpi	r24, 0x08	; 8
     e70:	b9 f0       	breq	.+46     	; 0xea0 <turnOffPWM+0x46>
     e72:	84 30       	cpi	r24, 0x04	; 4
     e74:	d1 f4       	brne	.+52     	; 0xeaa <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     e76:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
     e7a:	8f 7d       	andi	r24, 0xDF	; 223
     e7c:	03 c0       	rjmp	.+6      	; 0xe84 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     e7e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
     e82:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     e84:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
     e88:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     e8a:	84 b5       	in	r24, 0x24	; 36
     e8c:	8f 77       	andi	r24, 0x7F	; 127
     e8e:	02 c0       	rjmp	.+4      	; 0xe94 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     e90:	84 b5       	in	r24, 0x24	; 36
     e92:	8f 7d       	andi	r24, 0xDF	; 223
     e94:	84 bd       	out	0x24, r24	; 36
     e96:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     e98:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
     e9c:	8f 77       	andi	r24, 0x7F	; 127
     e9e:	03 c0       	rjmp	.+6      	; 0xea6 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     ea0:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
     ea4:	8f 7d       	andi	r24, 0xDF	; 223
     ea6:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
     eaa:	08 95       	ret

00000eac <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
     eac:	cf 93       	push	r28
     eae:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
     eb0:	90 e0       	ldi	r25, 0x00	; 0
     eb2:	fc 01       	movw	r30, r24
     eb4:	e4 58       	subi	r30, 0x84	; 132
     eb6:	ff 4f       	sbci	r31, 0xFF	; 255
     eb8:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
     eba:	fc 01       	movw	r30, r24
     ebc:	e0 57       	subi	r30, 0x70	; 112
     ebe:	ff 4f       	sbci	r31, 0xFF	; 255
     ec0:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     ec2:	88 23       	and	r24, r24
     ec4:	61 f1       	breq	.+88     	; 0xf1e <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     ec6:	90 e0       	ldi	r25, 0x00	; 0
     ec8:	88 0f       	add	r24, r24
     eca:	99 1f       	adc	r25, r25
     ecc:	fc 01       	movw	r30, r24
     ece:	e2 55       	subi	r30, 0x52	; 82
     ed0:	ff 4f       	sbci	r31, 0xFF	; 255
     ed2:	c5 91       	lpm	r28, Z+
     ed4:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
     ed6:	fc 01       	movw	r30, r24
     ed8:	ec 55       	subi	r30, 0x5C	; 92
     eda:	ff 4f       	sbci	r31, 0xFF	; 255
     edc:	a5 91       	lpm	r26, Z+
     ede:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
     ee0:	61 11       	cpse	r22, r1
     ee2:	09 c0       	rjmp	.+18     	; 0xef6 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
     ee4:	9f b7       	in	r25, 0x3f	; 63
                cli();
     ee6:	f8 94       	cli
		*reg &= ~bit;
     ee8:	88 81       	ld	r24, Y
     eea:	20 95       	com	r18
     eec:	82 23       	and	r24, r18
     eee:	88 83       	st	Y, r24
		*out &= ~bit;
     ef0:	ec 91       	ld	r30, X
     ef2:	2e 23       	and	r18, r30
     ef4:	0b c0       	rjmp	.+22     	; 0xf0c <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
     ef6:	62 30       	cpi	r22, 0x02	; 2
     ef8:	61 f4       	brne	.+24     	; 0xf12 <pinMode+0x66>
		uint8_t oldSREG = SREG;
     efa:	9f b7       	in	r25, 0x3f	; 63
                cli();
     efc:	f8 94       	cli
		*reg &= ~bit;
     efe:	88 81       	ld	r24, Y
     f00:	32 2f       	mov	r19, r18
     f02:	30 95       	com	r19
     f04:	83 23       	and	r24, r19
     f06:	88 83       	st	Y, r24
		*out |= bit;
     f08:	ec 91       	ld	r30, X
     f0a:	2e 2b       	or	r18, r30
     f0c:	2c 93       	st	X, r18
		SREG = oldSREG;
     f0e:	9f bf       	out	0x3f, r25	; 63
     f10:	06 c0       	rjmp	.+12     	; 0xf1e <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
     f12:	8f b7       	in	r24, 0x3f	; 63
                cli();
     f14:	f8 94       	cli
		*reg |= bit;
     f16:	e8 81       	ld	r30, Y
     f18:	2e 2b       	or	r18, r30
     f1a:	28 83       	st	Y, r18
		SREG = oldSREG;
     f1c:	8f bf       	out	0x3f, r24	; 63
	}
}
     f1e:	df 91       	pop	r29
     f20:	cf 91       	pop	r28
     f22:	08 95       	ret

00000f24 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
     f24:	1f 93       	push	r17
     f26:	cf 93       	push	r28
     f28:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
     f2a:	28 2f       	mov	r18, r24
     f2c:	30 e0       	ldi	r19, 0x00	; 0
     f2e:	f9 01       	movw	r30, r18
     f30:	e8 59       	subi	r30, 0x98	; 152
     f32:	ff 4f       	sbci	r31, 0xFF	; 255
     f34:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
     f36:	f9 01       	movw	r30, r18
     f38:	e4 58       	subi	r30, 0x84	; 132
     f3a:	ff 4f       	sbci	r31, 0xFF	; 255
     f3c:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
     f3e:	f9 01       	movw	r30, r18
     f40:	e0 57       	subi	r30, 0x70	; 112
     f42:	ff 4f       	sbci	r31, 0xFF	; 255
     f44:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     f46:	cc 23       	and	r28, r28
     f48:	c1 f0       	breq	.+48     	; 0xf7a <digitalWrite+0x56>
     f4a:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     f4c:	81 11       	cpse	r24, r1
     f4e:	0e 94 2d 07 	call	0xe5a	; 0xe5a <turnOffPWM>

	out = portOutputRegister(port);
     f52:	ec 2f       	mov	r30, r28
     f54:	f0 e0       	ldi	r31, 0x00	; 0
     f56:	ee 0f       	add	r30, r30
     f58:	ff 1f       	adc	r31, r31
     f5a:	ec 55       	subi	r30, 0x5C	; 92
     f5c:	ff 4f       	sbci	r31, 0xFF	; 255
     f5e:	a5 91       	lpm	r26, Z+
     f60:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
     f62:	9f b7       	in	r25, 0x3f	; 63
	cli();
     f64:	f8 94       	cli

	if (val == LOW) {
     f66:	11 11       	cpse	r17, r1
     f68:	04 c0       	rjmp	.+8      	; 0xf72 <digitalWrite+0x4e>
		*out &= ~bit;
     f6a:	8c 91       	ld	r24, X
     f6c:	d0 95       	com	r29
     f6e:	d8 23       	and	r29, r24
     f70:	02 c0       	rjmp	.+4      	; 0xf76 <digitalWrite+0x52>
	} else {
		*out |= bit;
     f72:	ec 91       	ld	r30, X
     f74:	de 2b       	or	r29, r30
     f76:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
     f78:	9f bf       	out	0x3f, r25	; 63
}
     f7a:	df 91       	pop	r29
     f7c:	cf 91       	pop	r28
     f7e:	1f 91       	pop	r17
     f80:	08 95       	ret

00000f82 <__divmodhi4>:
     f82:	97 fb       	bst	r25, 7
     f84:	07 2e       	mov	r0, r23
     f86:	16 f4       	brtc	.+4      	; 0xf8c <__divmodhi4+0xa>
     f88:	00 94       	com	r0
     f8a:	07 d0       	rcall	.+14     	; 0xf9a <__divmodhi4_neg1>
     f8c:	77 fd       	sbrc	r23, 7
     f8e:	09 d0       	rcall	.+18     	; 0xfa2 <__divmodhi4_neg2>
     f90:	0e 94 f7 07 	call	0xfee	; 0xfee <__udivmodhi4>
     f94:	07 fc       	sbrc	r0, 7
     f96:	05 d0       	rcall	.+10     	; 0xfa2 <__divmodhi4_neg2>
     f98:	3e f4       	brtc	.+14     	; 0xfa8 <__divmodhi4_exit>

00000f9a <__divmodhi4_neg1>:
     f9a:	90 95       	com	r25
     f9c:	81 95       	neg	r24
     f9e:	9f 4f       	sbci	r25, 0xFF	; 255
     fa0:	08 95       	ret

00000fa2 <__divmodhi4_neg2>:
     fa2:	70 95       	com	r23
     fa4:	61 95       	neg	r22
     fa6:	7f 4f       	sbci	r23, 0xFF	; 255

00000fa8 <__divmodhi4_exit>:
     fa8:	08 95       	ret

00000faa <__udivmodsi4>:
     faa:	a1 e2       	ldi	r26, 0x21	; 33
     fac:	1a 2e       	mov	r1, r26
     fae:	aa 1b       	sub	r26, r26
     fb0:	bb 1b       	sub	r27, r27
     fb2:	fd 01       	movw	r30, r26
     fb4:	0d c0       	rjmp	.+26     	; 0xfd0 <__udivmodsi4_ep>

00000fb6 <__udivmodsi4_loop>:
     fb6:	aa 1f       	adc	r26, r26
     fb8:	bb 1f       	adc	r27, r27
     fba:	ee 1f       	adc	r30, r30
     fbc:	ff 1f       	adc	r31, r31
     fbe:	a2 17       	cp	r26, r18
     fc0:	b3 07       	cpc	r27, r19
     fc2:	e4 07       	cpc	r30, r20
     fc4:	f5 07       	cpc	r31, r21
     fc6:	20 f0       	brcs	.+8      	; 0xfd0 <__udivmodsi4_ep>
     fc8:	a2 1b       	sub	r26, r18
     fca:	b3 0b       	sbc	r27, r19
     fcc:	e4 0b       	sbc	r30, r20
     fce:	f5 0b       	sbc	r31, r21

00000fd0 <__udivmodsi4_ep>:
     fd0:	66 1f       	adc	r22, r22
     fd2:	77 1f       	adc	r23, r23
     fd4:	88 1f       	adc	r24, r24
     fd6:	99 1f       	adc	r25, r25
     fd8:	1a 94       	dec	r1
     fda:	69 f7       	brne	.-38     	; 0xfb6 <__udivmodsi4_loop>
     fdc:	60 95       	com	r22
     fde:	70 95       	com	r23
     fe0:	80 95       	com	r24
     fe2:	90 95       	com	r25
     fe4:	9b 01       	movw	r18, r22
     fe6:	ac 01       	movw	r20, r24
     fe8:	bd 01       	movw	r22, r26
     fea:	cf 01       	movw	r24, r30
     fec:	08 95       	ret

00000fee <__udivmodhi4>:
     fee:	aa 1b       	sub	r26, r26
     ff0:	bb 1b       	sub	r27, r27
     ff2:	51 e1       	ldi	r21, 0x11	; 17
     ff4:	07 c0       	rjmp	.+14     	; 0x1004 <__udivmodhi4_ep>

00000ff6 <__udivmodhi4_loop>:
     ff6:	aa 1f       	adc	r26, r26
     ff8:	bb 1f       	adc	r27, r27
     ffa:	a6 17       	cp	r26, r22
     ffc:	b7 07       	cpc	r27, r23
     ffe:	10 f0       	brcs	.+4      	; 0x1004 <__udivmodhi4_ep>
    1000:	a6 1b       	sub	r26, r22
    1002:	b7 0b       	sbc	r27, r23

00001004 <__udivmodhi4_ep>:
    1004:	88 1f       	adc	r24, r24
    1006:	99 1f       	adc	r25, r25
    1008:	5a 95       	dec	r21
    100a:	a9 f7       	brne	.-22     	; 0xff6 <__udivmodhi4_loop>
    100c:	80 95       	com	r24
    100e:	90 95       	com	r25
    1010:	bc 01       	movw	r22, r24
    1012:	cd 01       	movw	r24, r26
    1014:	08 95       	ret

00001016 <__tablejump2__>:
    1016:	ee 0f       	add	r30, r30
    1018:	ff 1f       	adc	r31, r31
    101a:	05 90       	lpm	r0, Z+
    101c:	f4 91       	lpm	r31, Z
    101e:	e0 2d       	mov	r30, r0
    1020:	09 94       	ijmp

00001022 <_exit>:
    1022:	f8 94       	cli

00001024 <__stop_program>:
    1024:	ff cf       	rjmp	.-2      	; 0x1024 <__stop_program>
